
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: whitesmoke;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: whitesmoke;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/AlexBlackNn/metrics/app/agent/app.go (0.0%)</option>
				
				<option value="file1">github.com/AlexBlackNn/metrics/app/agent/hash/hash.go (100.0%)</option>
				
				<option value="file2">github.com/AlexBlackNn/metrics/app/agent/restagentsender/v1/sender.go (0.0%)</option>
				
				<option value="file3">github.com/AlexBlackNn/metrics/app/agent/restagentsender/v2/sender.go (0.0%)</option>
				
				<option value="file4">github.com/AlexBlackNn/metrics/app/agent/restagentsender/v3/sender.go (0.0%)</option>
				
				<option value="file5">github.com/AlexBlackNn/metrics/app/server/app.go (24.1%)</option>
				
				<option value="file6">github.com/AlexBlackNn/metrics/cmd/agent/main.go (0.0%)</option>
				
				<option value="file7">github.com/AlexBlackNn/metrics/cmd/server/docs/docs.go (100.0%)</option>
				
				<option value="file8">github.com/AlexBlackNn/metrics/cmd/server/main.go (0.0%)</option>
				
				<option value="file9">github.com/AlexBlackNn/metrics/cmd/server/migrator/main.go (0.0%)</option>
				
				<option value="file10">github.com/AlexBlackNn/metrics/cmd/server/router/chi_router.go (100.0%)</option>
				
				<option value="file11">github.com/AlexBlackNn/metrics/cmd/staticlint/checker/checkanalyzer.go (100.0%)</option>
				
				<option value="file12">github.com/AlexBlackNn/metrics/cmd/staticlint/main.go (0.0%)</option>
				
				<option value="file13">github.com/AlexBlackNn/metrics/internal/config/configagent/config.go (60.0%)</option>
				
				<option value="file14">github.com/AlexBlackNn/metrics/internal/config/configserver/config.go (0.0%)</option>
				
				<option value="file15">github.com/AlexBlackNn/metrics/internal/domain/models/metric.go (90.6%)</option>
				
				<option value="file16">github.com/AlexBlackNn/metrics/internal/handlers/v1/metrics_handlers.go (38.2%)</option>
				
				<option value="file17">github.com/AlexBlackNn/metrics/internal/handlers/v2/health_handlers.go (62.5%)</option>
				
				<option value="file18">github.com/AlexBlackNn/metrics/internal/handlers/v2/metrics_handlers.go (47.1%)</option>
				
				<option value="file19">github.com/AlexBlackNn/metrics/internal/handlers/v2/metrics_handlers_response.go (96.2%)</option>
				
				<option value="file20">github.com/AlexBlackNn/metrics/internal/handlers/v3/metrics_handlers.go (55.3%)</option>
				
				<option value="file21">github.com/AlexBlackNn/metrics/internal/handlers/v3/metrics_handlers_response.go (45.5%)</option>
				
				<option value="file22">github.com/AlexBlackNn/metrics/internal/logger/logger.go (66.7%)</option>
				
				<option value="file23">github.com/AlexBlackNn/metrics/internal/middleware/HashChecker.go (38.2%)</option>
				
				<option value="file24">github.com/AlexBlackNn/metrics/internal/middleware/gzipDecompressor.go (34.6%)</option>
				
				<option value="file25">github.com/AlexBlackNn/metrics/internal/middleware/gzipcompressor/gzipCompressor.go (65.7%)</option>
				
				<option value="file26">github.com/AlexBlackNn/metrics/internal/middleware/gzipcompressor/gzipwriterpool.go (83.3%)</option>
				
				<option value="file27">github.com/AlexBlackNn/metrics/internal/middleware/logger.go (100.0%)</option>
				
				<option value="file28">github.com/AlexBlackNn/metrics/internal/migrator/apply_migration.go (0.0%)</option>
				
				<option value="file29">github.com/AlexBlackNn/metrics/internal/services/agentmetricsservice/monitor_service.go (0.0%)</option>
				
				<option value="file30">github.com/AlexBlackNn/metrics/internal/services/metricsservice/metric_service.go (54.2%)</option>
				
				<option value="file31">github.com/AlexBlackNn/metrics/pkg/storage/memstorage/database.go (0.0%)</option>
				
				<option value="file32">github.com/AlexBlackNn/metrics/pkg/storage/memstorage/gob_state_manager.go (22.4%)</option>
				
				<option value="file33">github.com/AlexBlackNn/metrics/pkg/storage/memstorage/json_state_manager.go (0.0%)</option>
				
				<option value="file34">github.com/AlexBlackNn/metrics/pkg/storage/memstorage/mem_storage.go (62.1%)</option>
				
				<option value="file35">github.com/AlexBlackNn/metrics/pkg/storage/memstorage/temp_metric.go (100.0%)</option>
				
				<option value="file36">github.com/AlexBlackNn/metrics/pkg/storage/postgres/postgres.go (75.9%)</option>
				
				<option value="file37">github.com/AlexBlackNn/metrics/pkg/storage/postgres/sql.go (100.0%)</option>
				
				<option value="file38">github.com/AlexBlackNn/metrics/pkg/storage/postgres/temp_metric.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package agent

import (
        "context"
        "log/slog"

        restagentsender "github.com/AlexBlackNn/metrics/app/agent/restagentsender/v2"
        "github.com/AlexBlackNn/metrics/internal/config/configagent"
)

type CollectSender interface {
        Collect(ctx context.Context)
        CollectAddition(ctx context.Context)
        Send(ctx context.Context)
}

// AppMonitor service consists all service layers.
type AppMonitor struct {
        MetricsService CollectSender
}

// NewAppMonitor creates App.
func NewAppMonitor(
        log *slog.Logger,
        cfg *configagent.Config,
) *AppMonitor <span class="cov0" title="0">{

        metricsService := restagentsender.New(
                log,
                cfg,
        )
        return &amp;AppMonitor{MetricsService: metricsService}
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package hash

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "hash"

        "github.com/AlexBlackNn/metrics/internal/config/configagent"
)

type MetricHash struct {
        hashCalculator hash.Hash
}

func New(cfg *configagent.Config) *MetricHash <span class="cov8" title="1">{
        return &amp;MetricHash{
                hashCalculator: hmac.New(sha256.New, []byte(cfg.HashKey)),
        }
}</span>

func (mh *MetricHash) MetricHash(body string) string <span class="cov8" title="1">{
        mh.hashCalculator.Write([]byte(body))
        metricHash := mh.hashCalculator.Sum(nil)
        base64Result := make([]byte, base64.StdEncoding.EncodedLen(len(metricHash)))
        base64.StdEncoding.Encode(base64Result, metricHash)
        return string(base64Result)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package v1

import (
        "context"
        "fmt"
        "log/slog"
        "net/http"
        "time"

        "github.com/AlexBlackNn/metrics/internal/config/configagent"
        "github.com/AlexBlackNn/metrics/internal/domain/models"
        "github.com/AlexBlackNn/metrics/internal/services/agentmetricsservice"
)

type Sender struct {
        log *slog.Logger
        cfg *configagent.Config
        *agentmetricsservice.MonitorService
}

func New(
        log *slog.Logger,
        cfg *configagent.Config,
) *Sender <span class="cov0" title="0">{
        return &amp;Sender{
                log,
                cfg,
                agentmetricsservice.New(log, cfg),
        }
}</span>

func (s *Sender) Send(ctx context.Context) <span class="cov0" title="0">{

        log := s.log.With(
                slog.String("info", "SERVICE LAYER: metricsHttpService.Transmit"),
        )
        client := http.Client{
                Timeout: time.Duration(s.cfg.AgentTimeout) * time.Second,
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{ // в 1 инкрименте "Редиректы не поддерживаются."
                        return http.ErrUseLastResponse
                }</span>}
        <span class="cov0" title="0">reportInterval := time.Duration(s.cfg.ReportInterval) * time.Second
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        for _, savedMetric := range s.GetMetrics() </span><span class="cov0" title="0">{
                                go func(savedMetric models.MetricInteraction) </span><span class="cov0" title="0">{
                                        savedMetricValue := savedMetric.GetStringValue()

                                        url := fmt.Sprintf("http://%s/update/%s/%s/%s", s.cfg.ServerAddr, savedMetric.GetType(), savedMetric.GetName(), savedMetricValue)
                                        log.Info("sending data", "url", url)

                                        req, err := http.NewRequest(http.MethodPost, url, nil) // (1)

                                        // TODO: need refactoring to better work with error.
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error("error creating http request")
                                                return
                                        }</span>

                                        //Would be better to add backoff, but in next task client itself can do it.
                                        //https://pkg.go.dev/github.com/cenkalti/backoff/v4#section-readme
                                        <span class="cov0" title="0">response, err := client.Do(req)

                                        // TODO: need refactoring to better work with error.
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error("error doing http request", "err", err.Error())
                                                return
                                        }</span>
                                        <span class="cov0" title="0">log.Info("sending data", "url", url, "status_code", response.StatusCode)
                                        response.Body.Close()</span>

                                }(savedMetric)
                        }
                        <span class="cov0" title="0">&lt;-time.After(reportInterval)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package v2

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/AlexBlackNn/metrics/app/agent/hash"
        "github.com/AlexBlackNn/metrics/internal/config/configagent"
        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "github.com/AlexBlackNn/metrics/internal/domain/models"
        "github.com/AlexBlackNn/metrics/internal/services/agentmetricsservice"
        "github.com/go-resty/resty/v2"
        "golang.org/x/time/rate"
)

type Sender struct {
        log *slog.Logger
        cfg *configagent.Config
        *agentmetricsservice.MonitorService
}

func New(
        log *slog.Logger,
        cfg *configagent.Config,
) *Sender <span class="cov0" title="0">{
        return &amp;Sender{
                log,
                cfg,
                agentmetricsservice.New(log, cfg),
        }
}</span>

func (s *Sender) Send(ctx context.Context) <span class="cov0" title="0">{

        log := s.log.With(
                slog.String("info", "SERVICE LAYER: metricsHttpService.Transmit"),
        )
        reportInterval := time.Duration(s.cfg.ReportInterval) * time.Second
        rateLimiter := rate.NewLimiter(rate.Limit(s.cfg.AgentRateLimit), s.cfg.AgentBurstTokens)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(reportInterval):<span class="cov0" title="0">
                        for _, savedMetric := range s.GetMetrics() </span><span class="cov0" title="0">{
                                err := rateLimiter.Wait(ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error(err.Error())
                                        return
                                }</span>
                                <span class="cov0" title="0">go func(savedMetric models.MetricInteraction) </span><span class="cov0" title="0">{
                                        restyClient := resty.New()
                                        restyClient.
                                                SetRetryCount(s.cfg.AgentRetryCount).
                                                SetRetryWaitTime(s.cfg.AgentRetryWaitTime).
                                                SetRetryMaxWaitTime(s.cfg.AgentRetryMaxWaitTime)

                                        var body string
                                        if savedMetric.GetType() == configserver.MetricTypeCounter </span><span class="cov0" title="0">{
                                                body = fmt.Sprintf(`{"id":"%s", "type":"%s", "delta": %d}`,
                                                        savedMetric.GetName(),
                                                        savedMetric.GetType(),
                                                        savedMetric.GetValue(),
                                                )
                                        }</span> else<span class="cov0" title="0"> {
                                                body = fmt.Sprintf(`{"id":"%s", "type":"%s", "value": %v}`,
                                                        savedMetric.GetName(),
                                                        savedMetric.GetType(),
                                                        savedMetric.GetValue(),
                                                )
                                        }</span>

                                        <span class="cov0" title="0">hashCalculator := hash.New(s.cfg)
                                        hashResult := hashCalculator.MetricHash(body)

                                        url := fmt.Sprintf("http://%s/update/", s.cfg.ServerAddr)
                                        log.Info("sending data", "url", url)

                                        resp, err := restyClient.R().
                                                SetHeader("Content-Type", "application/json").
                                                SetHeader("HashSHA256", hashResult).
                                                SetBody(body).
                                                Post(url)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error("error creating http request")
                                                return
                                        }</span>
                                        <span class="cov0" title="0">log.Info("http request finished successfully",
                                                "url", url,
                                                "statusCode", resp.StatusCode(),
                                                "body", string(resp.Body()),
                                        )</span>
                                }(savedMetric)
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package v3

import (
        "context"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "github.com/AlexBlackNn/metrics/internal/config/configagent"
        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "github.com/AlexBlackNn/metrics/internal/services/agentmetricsservice"
        "github.com/go-resty/resty/v2"
        "golang.org/x/time/rate"
)

type Sender struct {
        log *slog.Logger
        cfg *configagent.Config
        *agentmetricsservice.MonitorService
}

func New(
        log *slog.Logger,
        cfg *configagent.Config,
) *Sender <span class="cov0" title="0">{
        return &amp;Sender{
                log,
                cfg,
                agentmetricsservice.New(log, cfg),
        }
}</span>

func (s *Sender) Send(ctx context.Context) <span class="cov0" title="0">{

        log := s.log.With(
                slog.String("info", "SERVICE LAYER: metricsHttpService.Transmit"),
        )
        reportInterval := time.Duration(s.cfg.ReportInterval) * time.Second
        rateLimiter := rate.NewLimiter(rate.Limit(s.cfg.AgentRateLimit), s.cfg.AgentBurstTokens)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(reportInterval):<span class="cov0" title="0">

                        var body strings.Builder

                        body.WriteString("[")
                        for _, savedMetric := range s.GetMetrics() </span><span class="cov0" title="0">{
                                if savedMetric.GetType() == configserver.MetricTypeCounter </span><span class="cov0" title="0">{
                                        body.WriteString(fmt.Sprintf(`{"id":"%s", "type":"%s", "delta": %d},`,
                                                savedMetric.GetName(),
                                                savedMetric.GetType(),
                                                savedMetric.GetValue(),
                                        ))
                                }</span> else<span class="cov0" title="0"> {
                                        body.WriteString(fmt.Sprintf(`{"id":"%s", "type":"%s", "value": %v},`,
                                                savedMetric.GetName(),
                                                savedMetric.GetType(),
                                                savedMetric.GetValue(),
                                        ))
                                }</span>
                        }
                        // need to delete last comma
                        <span class="cov0" title="0">jsonBody := body.String()[:len(body.String())-1] + "]"

                        err := rateLimiter.Wait(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">restyClient := resty.New()
                        restyClient.
                                SetRetryCount(s.cfg.AgentRetryCount).
                                SetRetryWaitTime(s.cfg.AgentRetryWaitTime).
                                SetRetryMaxWaitTime(s.cfg.AgentRetryMaxWaitTime)

                        url := fmt.Sprintf("http://%s/updates/", s.cfg.ServerAddr)
                        log.Info("sending data", "url", url)
                        resp, err := restyClient.R().
                                SetHeader("Content-Type", "application/json").
                                SetBody(jsonBody).
                                Post(url)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("error creating http request")
                                return
                        }</span>
                        <span class="cov0" title="0">log.Info("http request finished successfully",
                                "url", url,
                                "statusCode", resp.StatusCode(),
                                "body", string(resp.Body()),
                        )</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package server

import (
        "context"
        "log/slog"
        "net/http"
        _ "net/http/pprof"
        "time"

        "github.com/AlexBlackNn/metrics/cmd/server/router"
        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "github.com/AlexBlackNn/metrics/internal/domain/models"
        "github.com/AlexBlackNn/metrics/internal/handlers/v1"
        v2 "github.com/AlexBlackNn/metrics/internal/handlers/v2"
        v3 "github.com/AlexBlackNn/metrics/internal/handlers/v3"
        "github.com/AlexBlackNn/metrics/internal/logger"
        "github.com/AlexBlackNn/metrics/internal/migrator"
        "github.com/AlexBlackNn/metrics/internal/services/metricsservice"
        "github.com/AlexBlackNn/metrics/pkg/storage/memstorage"
        "github.com/AlexBlackNn/metrics/pkg/storage/postgres"
        "github.com/golang-migrate/migrate/v4"
)

type MetricsStorage interface {
        UpdateMetric(
                ctx context.Context,
                metric models.MetricGetter,
        ) error
        UpdateSeveralMetrics(
                ctx context.Context,
                metrics map[string]models.MetricGetter,
        ) error
        GetMetric(
                ctx context.Context,
                metric models.MetricGetter,
        ) (models.MetricGetter, error)
        GetAllMetrics(
                ctx context.Context,
        ) ([]models.MetricGetter, error)
}

type HealthChecker interface {
        HealthCheck(
                ctx context.Context,
        ) error
}

// App service consists all entities needed to work.
type App struct {
        MetricsService   *metricsservice.MetricService
        HandlersV1       v1.MetricHandlers
        HandlersV2       v2.MetricHandlers
        HealthHandlersV2 v2.HealthHandlers
        HandlersV3       v3.MetricHandlers
        Cfg              *configserver.Config
        Log              *slog.Logger
        Srv              *http.Server
        DataBase         MetricsStorage
        HealthChecker    HealthChecker
}

// New creates App collecting service layer, config, logger and predefined storage layer.
func New() (*App, error) <span class="cov0" title="0">{

        cfg, err := configserver.New()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log := logger.New(cfg.Env)

        // Err is now skipped, but when migratings to postgres/sqlite/etc... err will be checked.
        if cfg.ServerDataBaseDSN != "" </span><span class="cov0" title="0">{
                postgresStorage, err := postgres.New(cfg, log)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">log.Info("Starts to apply migrations")
                err = migrator.ApplyMigration(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        if err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                                log.Error("Failed to apply migration", "err", err.Error())
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">log.Info("No migration to apply")
                        return NewAppInitStorage(postgresStorage, postgresStorage, cfg, log)</span>
                }
                <span class="cov0" title="0">log.Info("Finish to apply migrations")
                return NewAppInitStorage(postgresStorage, postgresStorage, cfg, log)</span>
        }
        <span class="cov0" title="0">memStorage, err := memstorage.New(cfg, log)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewAppInitStorage(memStorage, memStorage, cfg, log)</span>
}

func NewAppInitStorage(ms MetricsStorage, hc HealthChecker, cfg *configserver.Config, log *slog.Logger) (*App, error) <span class="cov8" title="1">{

        metricsService := metricsservice.New(
                log,
                cfg,
                ms,
                hc,
        )

        projectHandlersV1 := v1.New(log, metricsService)
        projectHandlersV2 := v2.New(log, metricsService)
        healthHandlersV2 := v2.NewHealth(log, metricsService)
        projectHandlersV3 := v3.New(log, metricsService)

        srv := &amp;http.Server{
                Addr: cfg.ServerAddr,
                Handler: router.NewChiRouter(
                        cfg,
                        log,
                        projectHandlersV1,
                        projectHandlersV2,
                        healthHandlersV2,
                        projectHandlersV3,
                ),
                ReadTimeout:  time.Duration(cfg.ServerReadTimeout) * time.Second,
                WriteTimeout: time.Duration(cfg.ServerWriteTimeout) * time.Second,
                IdleTimeout:  time.Duration(cfg.ServerIdleTimeout) * time.Second,
        }

        return &amp;App{
                MetricsService:   metricsService,
                HandlersV1:       projectHandlersV1,
                HandlersV2:       projectHandlersV2,
                HealthHandlersV2: healthHandlersV2,
                HandlersV3:       projectHandlersV3,
                Srv:              srv,
                Cfg:              cfg,
                Log:              log,
                DataBase:         ms,
                HealthChecker:    hc,
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "os/signal"
        "sync"
        "syscall"

        "github.com/AlexBlackNn/metrics/app/agent"
        "github.com/AlexBlackNn/metrics/internal/config/configagent"
        "github.com/AlexBlackNn/metrics/internal/logger"
)

var buildVersion string
var buildDate string
var buildCommit string

func main() <span class="cov0" title="0">{
        var wg sync.WaitGroup

        cfg, err := configagent.New()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">log := logger.New(cfg.Env)
        showProjectInfo(log)
        log.Info("starting application", slog.String("env", cfg.Env))

        appMonitor := agent.NewAppMonitor(log, cfg)

        ctx := context.Background()
        ctx, cancel := context.WithCancel(ctx)

        stop := make(chan os.Signal, 1)
        signal.Notify(stop, syscall.SIGTERM, syscall.SIGINT)

        wg.Add(4)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                &lt;-stop
                cancel()
        }</span>()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                appMonitor.MetricsService.Collect(ctx)
        }</span>()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                appMonitor.MetricsService.CollectAddition(ctx)
        }</span>()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                appMonitor.MetricsService.Send(ctx)
        }</span>()

        <span class="cov0" title="0">wg.Wait()</span>
}

func showProjectInfo(log *slog.Logger) <span class="cov0" title="0">{
        if buildVersion == "" </span><span class="cov0" title="0">{
                buildVersion = "N/A"
        }</span>
        <span class="cov0" title="0">if buildDate == "" </span><span class="cov0" title="0">{
                buildDate = "N/A"
        }</span>
        <span class="cov0" title="0">if buildCommit == "" </span><span class="cov0" title="0">{
                buildCommit = "N/A"
        }</span>
        <span class="cov0" title="0">projInfo := fmt.Sprintf(
                "Build version: %s, Build date: %s, Build commit: %s",
                buildVersion, buildDate, buildCommit,
        )
        log.Info(projInfo)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "API Support"
        },
        "license": {
            "name": "Apache 2.0"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/ping": {
            "get": {
                "description": "Определяет можно ли подавать трафик на сервис",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Health"
                ],
                "summary": "Проверка готовности приложения",
                "operationId": "infoHealth",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/v2.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/v2.Response"
                        }
                    }
                }
            }
        },
        "/update/": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "update metric in DB",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Metrics"
                ],
                "summary": "UpdateMetric",
                "parameters": [
                    {
                        "description": "metric request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/v2.Metrics"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful metric update",
                        "schema": {
                            "$ref": "#/definitions/v2.Metrics"
                        }
                    }
                }
            }
        },
        "/value/": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get metric from DB",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Metrics"
                ],
                "summary": "GetOneMetric",
                "parameters": [
                    {
                        "description": "metric request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/v2.Metrics"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful metric provision",
                        "schema": {
                            "$ref": "#/definitions/v2.Metrics"
                        }
                    },
                    "404": {
                        "description": "Metric not found",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "v2.Metrics": {
            "type": "object",
            "properties": {
                "delta": {
                    "description": "exists if mType = counter",
                    "type": "integer"
                },
                "id": {
                    "description": "metrics name",
                    "type": "string"
                },
                "type": {
                    "description": "mType = counter || gauge",
                    "type": "string",
                    "enum": [
                        "gauge",
                        "counter"
                    ]
                },
                "value": {
                    "description": "exists if mType = gauge",
                    "type": "number"
                }
            }
        },
        "v2.Response": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "Swagger API",
        Description:      "metric collection service.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "fmt"
        "log/slog"
        "os"
        "os/signal"
        "syscall"

        "github.com/AlexBlackNn/metrics/app/server"
)

var buildVersion string
var buildDate string
var buildCommit string

// @title           Swagger API
// @version         1.0
// @description     metric collection service.
// @contact.name   API Support
// @license.name  Apache 2.0
// @license.calculation   http://www.apache.org/licenses/LICENSE-2.0.html
// @host      localhost:8080
//
//go:generate go run github.com/swaggo/swag/cmd/swag init
func main() <span class="cov0" title="0">{

        application, err := server.New()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">stop := make(chan os.Signal, 1)
        signal.Notify(stop, syscall.SIGTERM, syscall.SIGINT)

        showProjectInfo(application.Log)
        application.Log.Info("starting application", slog.String("cfg", application.Cfg.String()))

        go func() </span><span class="cov0" title="0">{
                if err = application.Srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }()
        <span class="cov0" title="0">application.Log.Info("server started")

        signalType := &lt;-stop
        application.Log.Info(
                "application stopped",
                slog.String("signalType",
                        signalType.String()),
        )</span>

}

func showProjectInfo(log *slog.Logger) <span class="cov0" title="0">{
        if buildVersion == "" </span><span class="cov0" title="0">{
                buildVersion = "N/A"
        }</span>
        <span class="cov0" title="0">if buildDate == "" </span><span class="cov0" title="0">{
                buildDate = "N/A"
        }</span>
        <span class="cov0" title="0">if buildCommit == "" </span><span class="cov0" title="0">{
                buildCommit = "N/A"
        }</span>
        <span class="cov0" title="0">projInfo := fmt.Sprintf(
                "Build version: %s, Build date: %s, Build commit: %s",
                buildVersion, buildDate, buildCommit,
        )
        log.Info(projInfo)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "errors"
        "flag"
        "fmt"
        // migration lib
        "github.com/golang-migrate/migrate/v4"
        // driver for migration applying postgres
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        // driver to get migrations from files (*.sql in our case)
        _ "github.com/golang-migrate/migrate/v4/source/file"
)

func main() <span class="cov0" title="0">{

        var migrationsPath, migrationsTable, databaseDSN string

        flag.StringVar(
                &amp;databaseDSN,
                "d",
                "",
                "database-dsn",
        )

        flag.StringVar(
                &amp;migrationsPath,
                "p",
                "",
                "path to migrations",
        )
        flag.StringVar(
                &amp;migrationsTable,
                "t",
                "migrations",
                "name of migration table, where migrator writes own data",
        )
        flag.Parse()

        if migrationsPath == "" </span><span class="cov0" title="0">{
                panic("migrations path is required")</span>
        }

        <span class="cov0" title="0">m, err := migrate.New(
                "file://"+migrationsPath,
                databaseDSN,
        )
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">if err := m.Up(); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                        fmt.Println("no migrations to apply")
                        return
                }</span>
                <span class="cov0" title="0">panic(err)</span>
        }
        <span class="cov0" title="0">fmt.Println("migrations applied successfully")</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package router

import (
        "compress/gzip"
        "log/slog"
        "time"

        _ "github.com/AlexBlackNn/metrics/cmd/server/docs"
        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "github.com/AlexBlackNn/metrics/internal/handlers/v1"
        "github.com/AlexBlackNn/metrics/internal/handlers/v2"
        v3 "github.com/AlexBlackNn/metrics/internal/handlers/v3"
        customMiddleware "github.com/AlexBlackNn/metrics/internal/middleware"
        "github.com/AlexBlackNn/metrics/internal/middleware/gzipcompressor"
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "github.com/go-chi/httprate"
        httpSwagger "github.com/swaggo/http-swagger/v2"
)

func NewChiRouter(
        cfg *configserver.Config,
        log *slog.Logger,
        metricHandlerV1 v1.MetricHandlers,
        metricHandlerV2 v2.MetricHandlers,
        healthHandlerV2 v2.HealthHandlers,
        metricHandlerV3 v3.MetricHandlers,
) *chi.Mux <span class="cov8" title="1">{

        router := chi.NewRouter()
        router.Use(middleware.RequestID)
        //        Rate limit by IP and URL path (aka endpoint)
        router.Use(httprate.Limit(
                cfg.ServerRateLimit, // requests
                time.Second,         // per duration
                httprate.WithKeyFuncs(httprate.KeyByIP, httprate.KeyByEndpoint),
        ))
        router.Use(customMiddleware.Logger(log))
        router.Use(middleware.Recoverer)

        router.Route("/", func(r chi.Router) </span><span class="cov8" title="1">{
                r.Use(customMiddleware.HashChecker(log, cfg))
                r.Use(customMiddleware.GzipDecompressor(log))
                r.Use(gzipcompressor.GzipCompressor(gzip.BestCompression))
                r.Get("/", metricHandlerV1.GetAllMetrics)
                r.Post("/update/{metric_type}/{metric_name}/{metric_value}", metricHandlerV1.UpdateMetric)
                r.Get("/value/{metric_type}/{metric_name}", metricHandlerV1.GetOneMetric)
                r.Post("/update/", metricHandlerV2.UpdateMetric)
                r.Post("/updates/", metricHandlerV3.UpdateSeveralMetrics)
                r.Post("/value/", metricHandlerV2.GetOneMetric)
        }</span>)
        <span class="cov8" title="1">router.Mount("/debug/", middleware.Profiler())
        router.Get("/ping", healthHandlerV2.ReadinessProbe)
        router.Route("/swagger", func(r chi.Router) </span><span class="cov8" title="1">{
                r.Get("/*", httpSwagger.Handler(
                        httpSwagger.URL("http://localhost:8080/swagger/doc.json"),
                ))
        }</span>)
        <span class="cov8" title="1">return router</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package checker

import (
        "go/ast"

        "golang.org/x/tools/go/analysis"
)

var ExitCheckAnalyzer = &amp;analysis.Analyzer{
        Name: "exitcheck",
        Doc:  "check if os.exit exists",
        Run:  run,
}

func run(pass *analysis.Pass) (interface{}, error) <span class="cov8" title="1">{
        for _, file := range pass.Files </span><span class="cov8" title="1">{
                ast.Inspect(file, func(node ast.Node) bool </span><span class="cov8" title="1">{
                        if x, ok := node.(*ast.CallExpr); ok </span><span class="cov8" title="1">{
                                if s, ok := x.Fun.(*ast.SelectorExpr); ok </span><span class="cov8" title="1">{
                                        if s.Sel.Name == "Exit" </span><span class="cov8" title="1">{
                                                pass.Reportf(s.Pos(), "using os.Exit is prohibbited")
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">return true</span>
                })
        }
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package main

import (
        "encoding/json"
        "os"
        "path/filepath"

        "github.com/AlexBlackNn/metrics/cmd/staticlint/checker"
        "github.com/fatih/addlint/addcheck"
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "honnef.co/go/tools/staticcheck"
)

// Config — имя файла конфигурации.
const Config = `config.json`

// ConfigData описывает структуру файла конфигурации.
type ConfigData struct {
        Staticcheck []string
}

func main() <span class="cov0" title="0">{
        appfile, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">data, err := os.ReadFile(filepath.Join(filepath.Dir(appfile), Config))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">var cfg ConfigData
        if err = json.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">mychecks := []*analysis.Analyzer{
                checker.ExitCheckAnalyzer,
                printf.Analyzer,
                shadow.Analyzer,
                structtag.Analyzer,
                addcheck.Analyzer,
        }
        checks := make(map[string]bool)
        for _, v := range cfg.Staticcheck </span><span class="cov0" title="0">{
                checks[v] = true
        }</span>
        <span class="cov0" title="0">for _, v := range staticcheck.Analyzers </span><span class="cov0" title="0">{
                if checks[v.Analyzer.Name] </span><span class="cov0" title="0">{
                        mychecks = append(mychecks, v.Analyzer)
                }</span>
        }

        <span class="cov0" title="0">multichecker.Main(
                mychecks...,
        )</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package configagent

import (
        "flag"
        "fmt"
        "os"
        "time"

        "github.com/AlexBlackNn/metrics/internal/config"
        "github.com/caarlos0/env/v6"
        "github.com/ilyakaznacheev/cleanenv"
)

const (
        MetricTypeCounter = "counter"
        MetricTypeGauge   = "gauge"
)

// Config consists project settings.
type Config struct {
        Env                   string        `yaml:"env" env-default:"local" env:"ENV"`
        ServerAddr            string        `yaml:"server_addr" env-default:":8080" env:"ADDRESS"`
        PollInterval          int           `yaml:"poll_interval" env-default:"2" env:"POLL_INTERVAL"`
        ReportInterval        int           `yaml:"report_interval" env-default:"10" env:"REPORT_INTERVAL"`
        AgentTimeout          int           `yaml:"client_timeout" env:"CLIENT_TIMEOUT"`
        AgentRetryCount       int           `yaml:"agent_retry_count" env-default:"30" env:"AGENT_RETRY_COUNT" envDefault:"3"`
        AgentRetryWaitTime    time.Duration `yaml:"agent_retry_wait_time" env-default:"30s" env:"AGENT_RETRY_WAIT_TIME" envDefault:"30s"`
        AgentRetryMaxWaitTime time.Duration `yaml:"agent_retry_max_wait_time" env-default:"90s" env:"AGENT_RETRY_MAX_WAIT_TIME" envDefault:"90s"`
        AgentRateLimit        int           `yaml:"agent_rate_limit" env-default:"100" env:"RATE_LIMIT" envDefault:"100"`
        AgentBurstTokens      int           `yaml:"agent_burst_tokens" env-default:"100" env:"AGENT_BURST_TOKENS" envDefault:"100"`
        HashKey               string        `yaml:"hash_key" env:"KEY"`
}

func (c *Config) String() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "Env: %s,"+
                        " ServerAddr: %s, "+
                        "PollInterval: %d,"+
                        " ReportInterval: %d,"+
                        " ClientTimeout: %d",
                c.Env,
                c.ServerAddr,
                c.PollInterval,
                c.ReportInterval,
                c.AgentTimeout,
        )
}</span>

// fetchConfigPath fetches config path from command line flag or env var
// Priority: env -&gt; yml -&gt; flag -&gt; default

// New loads config
func New() (*Config, error) <span class="cov8" title="1">{
        cfg := &amp;Config{}
        var err error
        var configPath string

        flag.StringVar(&amp;cfg.Env, "e", "local", "project environment")
        flag.StringVar(&amp;cfg.ServerAddr, "a", ":8080", "host address")
        flag.StringVar(&amp;cfg.HashKey, "k", "", "hash key")
        flag.IntVar(&amp;cfg.ReportInterval, "r", 2, "metrics report interval")
        flag.IntVar(&amp;cfg.PollInterval, "p", 1, "metrics poll interval")
        flag.IntVar(&amp;cfg.AgentTimeout, "t", 1, "agent request timeout")
        flag.IntVar(&amp;cfg.AgentRateLimit, "l", 100, "agent rate limit")
        flag.StringVar(&amp;configPath, "c", "", "path to config file")
        flag.Parse()

        if configPath == "" </span><span class="cov8" title="1">{
                configPath = os.Getenv("CONFIG_PATH")
        }</span>
        <span class="cov8" title="1">if configPath != "" </span><span class="cov0" title="0">{
                cfg, err = LoadByPath(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;Config{}, err
                }</span>
                <span class="cov0" title="0">return cfg, nil</span>
        }

        <span class="cov8" title="1">err = env.Parse(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return cfg, err
        }</span>
        <span class="cov8" title="1">return cfg, nil</span>
}

// LoadByPath loads config by path
func LoadByPath(configPath string) (*Config, error) <span class="cov0" title="0">{
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return &amp;Config{}, config.ErrAbsentConfigFile
        }</span>

        <span class="cov0" title="0">var cfg Config
        if err := cleanenv.ReadConfig(configPath, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return &amp;Config{}, config.ErrReadConfigFailed
        }</span>
        <span class="cov0" title="0">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package configserver

import (
        "flag"
        "fmt"
        "os"

        "github.com/AlexBlackNn/metrics/internal/config"
        "github.com/caarlos0/env/v6"
        "github.com/ilyakaznacheev/cleanenv"
)

const (
        MetricTypeCounter = "counter"
        MetricTypeGauge   = "gauge"
)

// Config consists project settings.
type Config struct {
        Env                   string `yaml:"env" env-default:"local" env:"ENV"`
        ServerAddr            string `yaml:"server_addr" env-default:":8080" env:"ADDRESS"`
        ServerReadTimeout     int    `yaml:"server_read_timeout" env-default:"100" env:"SEVER_READ_TIMEOUT" envDefault:"100"`
        ServerWriteTimeout    int    `yaml:"server_write_timeout" env-default:"100" env:"SEVER_WRITE_TIMEOUT" envDefault:"1000000000"`
        ServerIdleTimeout     int    `yaml:"server_idle_timeout" env-default:"100" env:"SEVER_IDLE_TIMEOUT" envDefault:"100"`
        ServerRequestTimeout  int    `yaml:"server_request_timeout" env-default:"300" env:"SEVER_REQUEST_TIMEOUT" envDefault:"300"`
        ServerStoreInterval   int    `yaml:"server_store_interval" env:"STORE_INTERVAL"`
        ServerFileStoragePath string `yaml:"server_file_storage_path" env-default:"/tmp/metrics-db.json" env:"FILE_STORAGE_PATH" envDefault:"/tmp/metrics-db.json"`
        ServerRestore         bool   `yaml:"server_restore" env-default:"true" env:"RESTORE" envDefault:"true"`
        ServerRateLimit       int    `yaml:"server_rate_limit" env-default:"10000" env:"SERVER_RATE_LIMIT" envDefault:"10000"`
        ServerDataBaseDSN     string `yaml:"server_data_base_dsn" env:"DATABASE_DSN"`
        ServerMigrationTable  string `yaml:"server_migration_table_name" env-default:"migrations" env:"SERVER_MIGRATION_TABLE_NAME" envDefault:"migrations"`
        HashKey               string `yaml:"hash_key" env:"KEY"`
}

func (c *Config) String() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "Env: %s,"+
                        " ServerAddr: %s, "+
                        "ServerReadTimeout: %d,"+
                        "ServerWriteTimeout: %d,"+
                        "ServerIdleTimeout: %d,"+
                        "ServerStoreInterval: %d,",
                c.Env,
                c.ServerAddr,
                c.ServerReadTimeout,
                c.ServerWriteTimeout,
                c.ServerIdleTimeout,
                c.ServerStoreInterval,
        )
}</span>

// fetchConfigPath fetches config path from command line flag or env var.
// Priority: env -&gt; yml -&gt; flag -&gt; default.

// New loads config
func New() (*Config, error) <span class="cov0" title="0">{
        cfg := &amp;Config{}
        var err error
        var configPath string

        flag.StringVar(&amp;cfg.Env, "e", "local", "project environment")
        flag.StringVar(&amp;cfg.ServerAddr, "a", ":8080", "host address")
        flag.StringVar(&amp;cfg.HashKey, "k", "", "hash key")
        flag.IntVar(&amp;cfg.ServerStoreInterval, "i", 1, "metrics store interval")
        flag.StringVar(&amp;cfg.ServerFileStoragePath, "f", "/tmp/metrics-db.json", "metrics store path")
        flag.BoolVar(&amp;cfg.ServerRestore, "r", true, "restore saved metrics")
        flag.StringVar(&amp;cfg.ServerDataBaseDSN, "d", "", "database dsn")

        flag.StringVar(&amp;configPath, "c", "", "path to config file")
        flag.Parse()

        if configPath == "" </span><span class="cov0" title="0">{
                configPath = os.Getenv("CONFIG_PATH")
        }</span>
        <span class="cov0" title="0">if configPath != "" </span><span class="cov0" title="0">{
                cfg, err = LoadByPath(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return cfg, nil</span>
        }

        <span class="cov0" title="0">err = env.Parse(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return cfg, nil</span>
}

// LoadByPath loads config by path
func LoadByPath(configPath string) (*Config, error) <span class="cov0" title="0">{
        _, err := os.Stat(configPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, config.ErrAbsentConfigFile
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("LoadByPath stat error: %w", err)</span>
        }
        <span class="cov0" title="0">var cfg Config
        if err := cleanenv.ReadConfig(configPath, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, config.ErrReadConfigFailed
        }</span>
        <span class="cov0" title="0">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package models

import (
        "fmt"
        "strconv"

        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "golang.org/x/exp/constraints"
)

type MetricAdder interface {
        AddValue(metric MetricGetter) error
}

type MetricGetter interface {
        GetType() string
        GetName() string
        GetValue() any
        GetStringValue() string
}

type MetricInteraction interface {
        MetricAdder
        MetricGetter
}

// Metric works with metrics collected by an agent.
type Metric[T constraints.Integer | constraints.Float] struct {
        Type  string
        Name  string
        Value T
}

func (m *Metric[T]) GetType() string <span class="cov8" title="1">{
        return m.Type
}</span>

func (m *Metric[T]) GetName() string <span class="cov8" title="1">{
        return m.Name
}</span>

func (m *Metric[T]) GetValue() any <span class="cov8" title="1">{
        return m.Value
}</span>

func (m *Metric[T]) GetStringValue() string <span class="cov8" title="1">{

        switch m.GetValue().(type) </span>{
        case uint64, uint32:<span class="cov8" title="1">
                return fmt.Sprintf("%d", m.GetValue())</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%f", m.GetValue())</span>
        }
}

// AddValue adds the value of another Metric to the current Metric.
func (m *Metric[T]) AddValue(other MetricGetter) error <span class="cov8" title="1">{
        if m.GetType() != other.GetType() </span><span class="cov8" title="1">{
                return ErrAddDifferentMetricType
        }</span>
        <span class="cov8" title="1">if m.GetName() != other.GetName() </span><span class="cov8" title="1">{
                return ErrAddDifferentMetricName
        }</span>

        // Since T is constrained to be either constraints.Float or constraints.Integer, we can use them here.
        <span class="cov8" title="1">if mValue, ok := any(m.Value).(float64); ok </span><span class="cov0" title="0">{
                if oValue, ok := other.GetValue().(float64); ok </span><span class="cov0" title="0">{
                        m.Value = T(mValue + oValue)
                }</span>
        }
        <span class="cov8" title="1">if mValue, ok := any(m.Value).(uint64); ok </span><span class="cov8" title="1">{
                if oValue, ok := other.GetValue().(uint64); ok </span><span class="cov8" title="1">{
                        m.Value = T(mValue + oValue)
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return ErrAddMetricValueCast</span>
}

func CheckModelType(metricType string) error <span class="cov8" title="1">{
        if metricType != configserver.MetricTypeGauge &amp;&amp; metricType != configserver.MetricTypeCounter </span><span class="cov8" title="1">{
                return ErrNotValidMetricType
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func New(metricType string, metricName string, metricValue string) (MetricInteraction, error) <span class="cov8" title="1">{

        if metricType == configserver.MetricTypeGauge </span><span class="cov8" title="1">{
                value, err := strconv.ParseFloat(metricValue, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, ErrNotValidMetricValue
                }</span>
                <span class="cov8" title="1">return &amp;Metric[float64]{
                        Type:  metricType,
                        Name:  metricName,
                        Value: value,
                }, nil</span>
        }

        <span class="cov8" title="1">if metricType == configserver.MetricTypeCounter </span><span class="cov8" title="1">{
                value, err := strconv.ParseUint(metricValue, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, ErrNotValidMetricValue
                }</span>
                <span class="cov8" title="1">return &amp;Metric[uint64]{
                        Type:  metricType,
                        Name:  metricName,
                        Value: value,
                }, nil</span>
        }
        <span class="cov8" title="1">return nil, ErrNotValidMetricType</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package v1

import (
        "errors"
        "fmt"
        "html/template"
        "log/slog"
        "net/http"
        "os"
        "path/filepath"
        "time"

        "github.com/AlexBlackNn/metrics/internal/domain/models"
        "github.com/AlexBlackNn/metrics/internal/services/metricsservice"
        "github.com/go-chi/chi/v5"
)

type MetricHandlers struct {
        log            *slog.Logger
        metricsService *metricsservice.MetricService
}

func New(log *slog.Logger, metricsService *metricsservice.MetricService) MetricHandlers <span class="cov8" title="1">{
        return MetricHandlers{log: log, metricsService: metricsService}
}</span>

func (m *MetricHandlers) GetAllMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()
        metrics, err := m.metricsService.GetAllMetrics(ctx)
        if errors.Is(err, metricsservice.ErrMetricNotFound) </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>
        <span class="cov0" title="0">path, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                m.log.Error("Error getting current work dir", "err", err.Error())
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">pathToTemplate := filepath.Join(path, "internal/handlers/v1/metrics.tmpl")
        tmpl, err := template.New("metrics").ParseFiles(pathToTemplate)
        if err != nil </span><span class="cov0" title="0">{
                m.log.Error("ParseFiles Error:", "err", err.Error(), "path:", pathToTemplate)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Date", time.Now().UTC().Format(http.TimeFormat))
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.WriteHeader(http.StatusOK)
        if err := tmpl.Execute(w, metrics); err != nil </span><span class="cov0" title="0">{
                m.log.Error("Error executing Go template")
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>
}

func (m *MetricHandlers) GetOneMetric(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">err := models.CheckModelType(chi.URLParam(r, "metric_type"))
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">ctx := r.Context()
        metric, err := models.New(chi.URLParam(r, "metric_type"), chi.URLParam(r, "metric_name"), "0")
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">metricReturned, err := m.metricsService.GetOneMetricValue(ctx, metric)
        if errors.Is(err, metricsservice.ErrMetricNotFound) </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Date", time.Now().UTC().Format(http.TimeFormat))
        w.Header().Set("Content-Type", "text/plain; charset=utf-8")
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(fmt.Sprintf("%v", metricReturned.GetValue())))</span>
}

func (m *MetricHandlers) UpdateMetric(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">metric, err := models.New(
                chi.URLParam(r, "metric_type"),
                chi.URLParam(r, "metric_name"),
                chi.URLParam(r, "metric_value"),
        )
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">ctx := r.Context()
        err = m.metricsService.UpdateMetricValue(ctx, metric)
        if errors.Is(err, metricsservice.ErrNotValidURL) </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Date", time.Now().UTC().Format(http.TimeFormat))
        w.Header().Set("Content-Type", "text/plain; charset=utf-8")
        w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package v2

import (
        "context"
        "errors"
        "log/slog"
        "net/http"
        "time"

        "github.com/AlexBlackNn/metrics/internal/services/metricsservice"
)

type HealthHandlers struct {
        log            *slog.Logger
        metricsService *metricsservice.MetricService
}

func NewHealth(log *slog.Logger, metricsService *metricsservice.MetricService) HealthHandlers <span class="cov8" title="1">{
        return HealthHandlers{log: log, metricsService: metricsService}
}</span>

// ReadinessProbe проверка готовности приложения.
// @ID infoHealth
// @Summary Проверка готовности приложения
// @Description Определяет можно ли подавать трафик на сервис
// @Tags Health
// @Produce json
// @Success 200 {object} v2.Response
// @Failure 500 {object} v2.Response
// @Router /ping [get]
func (m *HealthHandlers) ReadinessProbe(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                responseError(w, r, http.StatusMethodNotAllowed, "method not allowed")
                return
        }</span>
        <span class="cov8" title="1">ctx, cancel := context.WithTimeoutCause(r.Context(), 300*time.Millisecond, errors.New("readinessProbe timeout"))
        defer cancel()

        err := m.metricsService.HealthCheck(ctx)

        if err != nil </span><span class="cov0" title="0">{
                responseError(w, r, http.StatusInternalServerError, "internal server error")
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        responseHealth(w, r, http.StatusOK, "ready")</span>
}

func (m *HealthHandlers) LivenessProbe(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                responseError(w, r, http.StatusMethodNotAllowed, "method not allowed")
                return
        }</span>
        <span class="cov8" title="1">responseHealth(w, r, http.StatusOK, "alive")</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package v2

import (
        "context"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "time"

        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "github.com/AlexBlackNn/metrics/internal/domain/models"
        "github.com/AlexBlackNn/metrics/internal/services/metricsservice"
        "github.com/go-chi/render"
        "github.com/go-playground/validator/v10"
)

type MetricHandlers struct {
        log            *slog.Logger
        metricsService *metricsservice.MetricService
}

func New(log *slog.Logger, metricsService *metricsservice.MetricService) MetricHandlers <span class="cov8" title="1">{
        return MetricHandlers{log: log, metricsService: metricsService}
}</span>

// GetOneMetric get metric from DB.
// @Summary GetOneMetric
// @Description Get metric from DB
// @Tags Metrics
// @Accept json
// @Produce json
// @Param body body v2.Metrics true "metric request"
// @Success 200 {object}  v2.Metrics "Successful metric provision"
// @Failure 404 {string} string "Metric not found"
// @Router /value/ [post]
// @Security BearerAuth
func (m *MetricHandlers) GetOneMetric(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                responseError(w, r, http.StatusMethodNotAllowed, "method not allowed")
                return
        }</span>
        <span class="cov8" title="1">var reqMetrics Metrics
        // TODO: easyjson can be used?
        err := render.DecodeJSON(r.Body, &amp;reqMetrics)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        // Post with empty body
                        responseError(w, r, http.StatusBadRequest, "empty request")
                        return
                }</span>
                <span class="cov0" title="0">responseError(w, r, http.StatusBadRequest, "failed to decode request")
                return</span>
        }
        <span class="cov8" title="1">if err = validator.New().Struct(reqMetrics); err != nil </span><span class="cov0" title="0">{
                var validateErr validator.ValidationErrors
                if errors.As(err, &amp;validateErr) </span><span class="cov0" title="0">{
                        errorText := ValidationError(validateErr)
                        responseError(w, r, http.StatusBadRequest, errorText)
                        return
                }</span>
                <span class="cov0" title="0">responseError(w, r, http.StatusUnprocessableEntity, "failed to validate request")
                return</span>
        }
        <span class="cov8" title="1">ctx, cancel := context.WithTimeoutCause(r.Context(), 300*time.Millisecond, errors.New("getOneMetric timeout"))
        defer cancel()

        metric, err := models.New(reqMetrics.MType, reqMetrics.ID, "0")
        if err != nil </span><span class="cov0" title="0">{
                responseError(w, r, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov8" title="1">metricReturned, err := m.metricsService.GetOneMetricValue(ctx, metric)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, metricsservice.ErrMetricNotFound) </span><span class="cov0" title="0">{
                        responseError(w, r, http.StatusNotFound, "metric not found")
                        return
                }</span>
                <span class="cov0" title="0">responseError(w, r, http.StatusInternalServerError, "internal server error")
                return</span>
        }
        <span class="cov8" title="1">responseOK(w, r, metricReturned)</span>
}

// UpdateMetric update value of metric in DB.
// @Summary UpdateMetric
// @Description update metric in DB
// @Tags Metrics
// @Accept json
// @Produce json
// @Param body body v2.Metrics true "metric request"
// @Success 200 {object}  v2.Metrics "Successful metric update"
// @Router /update/ [post]
// @Security BearerAuth
func (m *MetricHandlers) UpdateMetric(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                responseError(w, r, http.StatusMethodNotAllowed, "method not allowed")
                return
        }</span>
        <span class="cov8" title="1">var reqMetrics Metrics
        err := render.DecodeJSON(r.Body, &amp;reqMetrics)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        // Post with empty body
                        responseError(w, r, http.StatusBadRequest, "empty request")
                        return
                }</span>
                <span class="cov0" title="0">responseError(w, r, http.StatusBadRequest, "failed to decode request")
                return</span>
        }
        <span class="cov8" title="1">if err = validator.New().Struct(reqMetrics); err != nil </span><span class="cov8" title="1">{
                var validateErr validator.ValidationErrors
                if errors.As(err, &amp;validateErr) </span><span class="cov8" title="1">{
                        errorText := ValidationError(validateErr)
                        responseError(w, r, http.StatusBadRequest, errorText)
                        return
                }</span>
                <span class="cov0" title="0">responseError(w, r, http.StatusUnprocessableEntity, "failed to validate request")
                return</span>
        }

        <span class="cov8" title="1">var metric models.MetricInteraction

        // TODO must be in service layer
        if reqMetrics.MType == configserver.MetricTypeCounter </span><span class="cov8" title="1">{
                metric, err = models.New(
                        reqMetrics.MType,
                        reqMetrics.ID,
                        fmt.Sprintf("%d", *reqMetrics.Delta),
                )
        }</span> else<span class="cov8" title="1"> {
                metric, err = models.New(
                        reqMetrics.MType,
                        reqMetrics.ID,
                        fmt.Sprintf("%g", *reqMetrics.Value),
                )
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                responseError(w, r, http.StatusBadRequest, "metric value conversion error")
                return
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeoutCause(r.Context(), 300*time.Millisecond, errors.New("updateMetric timeout"))
        defer cancel()

        err = m.metricsService.UpdateMetricValue(ctx, metric)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, metricsservice.ErrNotValidURL) </span><span class="cov0" title="0">{
                        responseError(w, r, http.StatusNotFound, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">responseError(w, r, http.StatusInternalServerError, "internal server error")
                return</span>
        }
        <span class="cov8" title="1">responseOK(w, r, metric)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package v2

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "github.com/AlexBlackNn/metrics/internal/domain/models"
        "github.com/go-playground/validator/v10"
        "github.com/mailru/easyjson"
)

type Metrics struct {
        ID    string   `json:"id"`                                  // metrics name
        MType string   `json:"type" validate:"oneof=gauge counter"` // mType = counter || gauge
        Delta *int64   `json:"delta,omitempty"`                     // exists if mType = counter
        Value *float64 `json:"value,omitempty"`                     // exists if mType = gauge
}

type Response struct {
        Status string `json:"status"`
        Error  string `json:"error,omitempty"`
}

const StatusError = "Error"

func Error(msg string) Response <span class="cov8" title="1">{
        return Response{
                Status: StatusError,
                Error:  msg,
        }
}</span>

func HealthOk(msg string) Response <span class="cov8" title="1">{
        return Response{
                Status: msg,
        }
}</span>

func ValidationError(errs validator.ValidationErrors) string <span class="cov8" title="1">{
        var errMsgs []string

        for _, err := range errs </span><span class="cov8" title="1">{
                switch err.ActualTag() </span>{
                case "required":<span class="cov0" title="0">
                        errMsgs = append(errMsgs, fmt.Sprintf("field %s is a required field", err.Field()))</span>
                default:<span class="cov8" title="1">
                        errMsgs = append(errMsgs, fmt.Sprintf("field %s is not valid", err.Field()))</span>
                }
        }

        <span class="cov8" title="1">return strings.Join(errMsgs, ", ")</span>
}

func responseOK(w http.ResponseWriter, r *http.Request, metric models.MetricGetter) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        if metric.GetType() == configserver.MetricTypeCounter </span><span class="cov8" title="1">{
                metricValue := int64(metric.GetValue().(uint64))
                metricMarshal, _ := easyjson.Marshal(Metrics{
                        ID:    metric.GetName(),
                        MType: metric.GetType(),
                        Delta: &amp;metricValue,
                })
                w.Write(metricMarshal)
                return
        }</span>
        <span class="cov8" title="1">metricValue := metric.GetValue().(float64)
        metricMarshal, _ := easyjson.Marshal(Metrics{
                ID:    metric.GetName(),
                MType: metric.GetType(),
                Value: &amp;metricValue,
        })
        w.Write(metricMarshal)</span>
}

func responseError(w http.ResponseWriter, r *http.Request, statusCode int, message string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        dataMarshal, _ := easyjson.Marshal(Error(message))
        w.Write(dataMarshal)
}</span>

func responseHealth(w http.ResponseWriter, r *http.Request, statusCode int, message string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        dataMarshal, _ := json.Marshal(HealthOk(message))
        w.Write(dataMarshal)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package v3

import (
        "context"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "time"

        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "github.com/AlexBlackNn/metrics/internal/domain/models"
        "github.com/AlexBlackNn/metrics/internal/services/metricsservice"
        "github.com/go-chi/render"
        "github.com/go-playground/validator/v10"
)

type MetricHandlers struct {
        log            *slog.Logger
        metricsService *metricsservice.MetricService
}

func New(log *slog.Logger, metricsService *metricsservice.MetricService) MetricHandlers <span class="cov8" title="1">{
        return MetricHandlers{log: log, metricsService: metricsService}
}</span>

func (m *MetricHandlers) UpdateSeveralMetrics(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                responseError(w, r, http.StatusMethodNotAllowed, "method not allowed")
                return
        }</span>
        <span class="cov8" title="1">var reqMetrics []Metrics
        err := render.DecodeJSON(r.Body, &amp;reqMetrics)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        // Post with empty body
                        responseError(w, r, http.StatusBadRequest, "empty request")
                        return
                }</span>
                <span class="cov0" title="0">responseError(w, r, http.StatusBadRequest, "failed to decode request")
                return</span>
        }

        <span class="cov8" title="1">var metric models.MetricInteraction
        severalMetrics := make([]models.MetricInteraction, len(reqMetrics))
        for i, oneMetric := range reqMetrics </span><span class="cov8" title="1">{

                if err = validator.New().Struct(reqMetrics); err != nil </span><span class="cov8" title="1">{
                        var validateErr validator.ValidationErrors
                        if errors.As(err, &amp;validateErr) </span><span class="cov0" title="0">{
                                errorText := ValidationError(validateErr)
                                responseError(w, r, http.StatusBadRequest, errorText)
                                return
                        }</span>
                }

                // TODO must be in service layer
                <span class="cov8" title="1">if oneMetric.MType == configserver.MetricTypeCounter </span><span class="cov8" title="1">{
                        metric, err = models.New(
                                oneMetric.MType,
                                oneMetric.ID,
                                fmt.Sprintf("%d", *oneMetric.Delta),
                        )
                }</span> else<span class="cov8" title="1"> {
                        metric, err = models.New(
                                oneMetric.MType,
                                oneMetric.ID,
                                fmt.Sprintf("%g", *oneMetric.Value),
                        )
                }</span>
                <span class="cov8" title="1">severalMetrics[i] = metric</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                responseError(w, r, http.StatusBadRequest, "metric value conversion error")
                return
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeoutCause(r.Context(), 300*time.Millisecond, errors.New("updateSeveralMetrics timeout"))
        defer cancel()

        err = m.metricsService.UpdateSeveralMetrics(ctx, severalMetrics)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, metricsservice.ErrNotValidURL) </span><span class="cov0" title="0">{
                        responseError(w, r, http.StatusNotFound, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">responseError(w, r, http.StatusInternalServerError, "internal server error")
                return</span>
        }
        <span class="cov8" title="1">responseOK(w, r, metric)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package v3

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "github.com/AlexBlackNn/metrics/internal/domain/models"
        "github.com/go-playground/validator/v10"
        "github.com/mailru/easyjson"
)

type Metrics struct {
        ID    string   `json:"id"`                                  // metrics name
        MType string   `json:"type" validate:"oneof=gauge counter"` // mType = counter || gauge
        Delta *int64   `json:"delta,omitempty"`                     // exists if mType = counter
        Value *float64 `json:"value,omitempty"`                     // exists if mType = gauge
}

type Response struct {
        Status string `json:"status"`
        Error  string `json:"error,omitempty"`
}

const StatusError = "Error"

func Error(msg string) Response <span class="cov0" title="0">{
        return Response{
                Status: StatusError,
                Error:  msg,
        }
}</span>

func HealthOk(msg string) Response <span class="cov0" title="0">{
        return Response{
                Status: msg,
        }
}</span>

func ValidationError(errs validator.ValidationErrors) string <span class="cov0" title="0">{
        var errMsgs []string

        for _, err := range errs </span><span class="cov0" title="0">{
                switch err.ActualTag() </span>{
                case "required":<span class="cov0" title="0">
                        errMsgs = append(errMsgs, fmt.Sprintf("field %s is a required field", err.Field()))</span>
                default:<span class="cov0" title="0">
                        errMsgs = append(errMsgs, fmt.Sprintf("field %s is not valid", err.Field()))</span>
                }
        }

        <span class="cov0" title="0">return strings.Join(errMsgs, ", ")</span>
}

func responseOK(w http.ResponseWriter, r *http.Request, metric models.MetricGetter) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        if metric.GetType() == configserver.MetricTypeCounter </span><span class="cov8" title="1">{
                metricValue := int64(metric.GetValue().(uint64))
                metricMarshal, _ := easyjson.Marshal(Metrics{
                        ID:    metric.GetName(),
                        MType: metric.GetType(),
                        Delta: &amp;metricValue,
                })
                w.Write(metricMarshal)
                return
        }</span>
        <span class="cov8" title="1">metricValue := metric.GetValue().(float64)
        metricMarshal, _ := easyjson.Marshal(Metrics{
                ID:    metric.GetName(),
                MType: metric.GetType(),
                Value: &amp;metricValue,
        })
        w.Write(metricMarshal)</span>
}

func responseError(w http.ResponseWriter, r *http.Request, statusCode int, message string) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        dataMarshal, _ := easyjson.Marshal(Error(message))
        w.Write(dataMarshal)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package logger

import (
        "log/slog"
        "os"
)

const (
        envLocal = "local"
        envDemo  = "demo"
        envProd  = "prod"
)

// New creates logger with predefine setting (depends on environment).
func New(env string) *slog.Logger <span class="cov8" title="1">{
        var log *slog.Logger

        switch env </span>{
        case envLocal:<span class="cov8" title="1">
                log = slog.New(
                        slog.NewTextHandler(
                                os.Stdout, &amp;slog.HandlerOptions{
                                        Level:     slog.LevelInfo,
                                        AddSource: true,
                                },
                        ),
                )</span>
        case envDemo:<span class="cov0" title="0">
                log = slog.New(
                        slog.NewJSONHandler(
                                os.Stdout, &amp;slog.HandlerOptions{
                                        Level:     slog.LevelDebug,
                                        AddSource: true,
                                },
                        ),
                )</span>
        case envProd:<span class="cov0" title="0">
                log = slog.New(
                        slog.NewJSONHandler(
                                os.Stdout, &amp;slog.HandlerOptions{
                                        Level:     slog.LevelInfo,
                                        AddSource: true,
                                },
                        ),
                )</span>
        }
        <span class="cov8" title="1">return log</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package middleware

import (
        "bytes"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "io"
        "log/slog"
        "net/http"
        "time"

        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "github.com/go-chi/chi/v5/middleware"
)

const StatusError = "Error"

type Response struct {
        Status string `json:"status"`
        Error  string `json:"error,omitempty"`
}

func Error(msg string) Response <span class="cov0" title="0">{
        return Response{
                Status: StatusError,
                Error:  msg,
        }
}</span>

func HashChecker(log *slog.Logger, cfg *configserver.Config) func(next http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                log := log.With(
                        slog.String("component", "middleware/HashChecker"),
                )

                log.Info("HashChecker middleware enabled")

                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        entry := log.With(
                                slog.String("method", r.Method),
                                slog.String("path", r.URL.Path),
                                slog.String("remote_addr", r.RemoteAddr),
                                slog.String("user_agent", r.UserAgent()),
                                slog.String("request_id", middleware.GetReqID(r.Context())),
                        )

                        hashBase64 := r.Header.Get("HashSHA256")
                        if hashBase64 != "" </span><span class="cov0" title="0">{
                                dst := make([]byte, base64.StdEncoding.DecodedLen(len(hashBase64)))
                                n, err := base64.StdEncoding.Decode(dst, []byte(hashBase64))
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error("base64 decode:", "err", err)
                                        return
                                }</span>
                                <span class="cov0" title="0">dst = dst[:n]

                                byteData, err := io.ReadAll(r.Body)

                                hashCalculator := hmac.New(sha256.New, []byte(cfg.HashKey))
                                hashCalculator.Write(byteData)
                                hashResult := hashCalculator.Sum(nil)

                                if !bytes.Equal(dst, hashResult) </span><span class="cov0" title="0">{
                                        log.Warn("hash validation failed", "err", err)
                                        w.Header().Set("Content-Type", "application/json")
                                        w.WriteHeader(http.StatusUnprocessableEntity)
                                        dataMarshal, _ := json.Marshal(Error("hash calculation failed"))
                                        _, err := w.Write(dataMarshal)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error("write error:", "err", err)
                                        }</span>
                                        <span class="cov0" title="0">return</span>
                                }

                                <span class="cov0" title="0">r.Body = io.NopCloser(bytes.NewBuffer(byteData))</span>
                        }

                        <span class="cov8" title="1">ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

                        t1 := time.Now()
                        defer func() </span><span class="cov8" title="1">{
                                entry.Info("request completed",
                                        slog.Int("status", ww.Status()),
                                        slog.Int("bytes", ww.BytesWritten()),
                                        slog.String("duration", time.Since(t1).String()),
                                )
                        }</span>()

                        <span class="cov8" title="1">next.ServeHTTP(ww, r)</span>
                }

                <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package middleware

import (
        "compress/gzip"
        "io"
        "log/slog"
        "net/http"
        "strings"
)

type compressReader struct {
        r  io.ReadCloser
        zr *gzip.Reader
}

func newCompressReader(r io.ReadCloser) (*compressReader, error) <span class="cov0" title="0">{
        zr, err := gzip.NewReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;compressReader{
                r:  r,
                zr: zr,
        }, nil</span>
}

func (c compressReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        return c.zr.Read(p)
}</span>

func (c *compressReader) Close() error <span class="cov0" title="0">{
        if err := c.r.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.zr.Close()</span>
}

func GzipDecompressor(log *slog.Logger) func(next http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                log := log.With(
                        slog.String("component", "middleware/gzip"),
                )
                log.Info("gzip decompressor middleware enabled")
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        contentEncoding := r.Header.Get("Content-Encoding")
                        sendsGzip := strings.Contains(contentEncoding, "gzip")
                        if sendsGzip </span><span class="cov0" title="0">{
                                cr, err := newCompressReader(r.Body)
                                if err != nil </span><span class="cov0" title="0">{
                                        w.WriteHeader(http.StatusInternalServerError)
                                        return
                                }</span>
                                <span class="cov0" title="0">r.Body = cr
                                defer func(cr *compressReader) </span><span class="cov0" title="0">{
                                        err := cr.Close()
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error("error closing gzip reader", "err", err.Error())
                                        }</span>
                                }(cr)
                        }
                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                }

                <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package gzipcompressor

import (
        "compress/gzip"
        "io"
        "net/http"
        "strings"
)

var gzipWrPool = &amp;gzipWriterPool{}

type GzipWriter struct {
        ResWriter http.ResponseWriter
        Writer    *gzip.Writer
        GzipFlag  bool
}

func (w *GzipWriter) Header() http.Header <span class="cov8" title="1">{
        return w.ResWriter.Header()
}</span>

func (w *GzipWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        if !strings.Contains(w.ResWriter.Header().Get("Content-Type"), "application/json") &amp;&amp;
                !strings.Contains(w.ResWriter.Header().Get("Content-Type"), "text/html") </span><span class="cov8" title="1">{
                w.GzipFlag = false
                w.ResWriter.WriteHeader(statusCode)
                return
        }</span>
        <span class="cov8" title="1">w.GzipFlag = true
        w.ResWriter.Header().Set("Content-Encoding", "gzip")
        w.ResWriter.WriteHeader(statusCode)</span>
}

func (w *GzipWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        if !strings.Contains(w.ResWriter.Header().Get("Content-Type"), "application/json") &amp;&amp;
                !strings.Contains(w.ResWriter.Header().Get("Content-Type"), "text/html") </span><span class="cov8" title="1">{
                return w.ResWriter.Write(b)
        }</span>
        <span class="cov8" title="1">return w.Writer.Write(b)</span>
}

func (w *GzipWriter) Close() error <span class="cov8" title="1">{
        return w.Writer.Close()
}</span>

func (w *GzipWriter) Flush() error <span class="cov0" title="0">{
        return w.Writer.Flush()
}</span>

func (w *GzipWriter) Reset() <span class="cov0" title="0">{
        w.Writer.Reset(io.Discard)
}</span>

func GzipCompressor(compressorLevel int) func(next http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{

                        if !strings.Contains(strings.Join(r.Header.Values("Accept-Encoding"), " "), "gzip") </span><span class="cov0" title="0">{
                                // If gzip is not supported then return uncompressed page.
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov8" title="1">gzipWr, err := gzipWrPool.get(w, compressorLevel)
                        if err != nil </span><span class="cov0" title="0">{
                                _, err = io.WriteString(w, err.Error())
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                        <span class="cov8" title="1">next.ServeHTTP(gzipWr, r)
                        if gzipWr.GzipFlag </span><span class="cov8" title="1">{
                                err = gzipWrPool.put(gzipWr)
                        }</span> else<span class="cov8" title="1"> {
                                err = gzipWrPool.putNoFlush(gzipWr)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                _, err = io.WriteString(w, err.Error())
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                }
                <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package gzipcompressor

import (
        "compress/gzip"
        "errors"
        "net/http"
        "sync"
)

type gzipWriterPool struct {
        p sync.Pool
}

func (gp *gzipWriterPool) get(
        w http.ResponseWriter,
        compressorLevel int,
) (*GzipWriter, error) <span class="cov8" title="1">{
        gzipWriter := gp.p.Get()
        if gzipWriter == nil </span><span class="cov8" title="1">{
                gzipWr, err := gzip.NewWriterLevel(w, compressorLevel)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;GzipWriter{ResWriter: w, Writer: gzipWr}, nil</span>
        }
        <span class="cov8" title="1">gzipWr, ok := gzipWriter.(*gzip.Writer)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("wrong type of gzipWriter")
        }</span>
        // need to reset old writer state
        <span class="cov8" title="1">gzipWr.Reset(w)
        return &amp;GzipWriter{ResWriter: w, Writer: gzipWr}, nil</span>
}

func (gp *gzipWriterPool) put(gzipWriter *GzipWriter) error <span class="cov8" title="1">{
        err := gzipWriter.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">gp.p.Put(gzipWriter.Writer)
        return nil</span>
}

func (gp *gzipWriterPool) putNoFlush(gzipWriter *GzipWriter) error <span class="cov8" title="1">{
        gp.p.Put(gzipWriter.Writer)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package middleware

import (
        "log/slog"
        "net/http"
        "time"

        "github.com/go-chi/chi/v5/middleware"
)

func Logger(log *slog.Logger) func(next http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                log := log.With(
                        slog.String("component", "middleware/logger"),
                )

                log.Info("logger middleware enabled")

                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        entry := log.With(
                                slog.String("method", r.Method),
                                slog.String("path", r.URL.Path),
                                slog.String("remote_addr", r.RemoteAddr),
                                slog.String("user_agent", r.UserAgent()),
                                slog.String("request_id", middleware.GetReqID(r.Context())),
                        )
                        ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

                        t1 := time.Now()
                        defer func() </span><span class="cov8" title="1">{
                                entry.Info("request completed",
                                        slog.Int("status", ww.Status()),
                                        slog.Int("bytes", ww.BytesWritten()),
                                        slog.String("duration", time.Since(t1).String()),
                                )
                        }</span>()

                        <span class="cov8" title="1">next.ServeHTTP(ww, r)</span>
                }

                <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package migrator

import (
        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        // migration lib
        "github.com/golang-migrate/migrate/v4"
        // driver for migration applying postgres
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        // driver to get migrations from files (*.sql in our case)
        _ "github.com/golang-migrate/migrate/v4/source/file"
)

func ApplyMigration(cfg *configserver.Config) error <span class="cov0" title="0">{
        m, err := migrate.New(
                "file://"+"./migrations",
                cfg.ServerDataBaseDSN,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err = m.Up(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package agentmetricsservice

import (
        "context"
        "log/slog"
        "math/rand"
        "runtime"
        "sync"
        "time"

        "github.com/AlexBlackNn/metrics/internal/config/configagent"
        "github.com/AlexBlackNn/metrics/internal/domain/models"
        "github.com/shirou/gopsutil/v4/cpu"
        "github.com/shirou/gopsutil/v4/mem"
)

type MonitorService struct {
        log     *slog.Logger
        cfg     *configagent.Config
        Metrics map[string]models.MetricInteraction
        mutex   sync.RWMutex
}

func New(
        log *slog.Logger,
        cfg *configagent.Config,
) *MonitorService <span class="cov0" title="0">{
        return &amp;MonitorService{
                Metrics: make(map[string]models.MetricInteraction),
                log:     log,
                cfg:     cfg,
        }
}</span>

// Collect starts collecting runtime metrics.
func (ms *MonitorService) Collect(ctx context.Context) <span class="cov0" title="0">{
        log := ms.log.With(
                slog.String("info", "SERVICE LAYER: agentmetricservice.Start"),
        )

        var rtm runtime.MemStats
        ms.Metrics["PollCount"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeCounter, Value: uint64(0), Name: "PollCount"}
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Info("stop signal received")
                        return</span>
                case &lt;-time.After(time.Duration(ms.cfg.PollInterval) * time.Second):<span class="cov0" title="0">
                        log.Info("starts Collect metric pooling")
                        // Read full mem stats
                        runtime.ReadMemStats(&amp;rtm)
                        ms.mutex.Lock()
                        ms.Metrics["Alloc"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.Alloc, Name: "Alloc"}
                        ms.Metrics["BuckHashSys"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.BuckHashSys, Name: "BuckHashSys"}
                        ms.Metrics["Frees"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.Frees, Name: "Frees"}
                        ms.Metrics["GCCPUFraction"] = &amp;models.Metric[float64]{Type: configagent.MetricTypeGauge, Value: rtm.GCCPUFraction, Name: "GCCPUFraction"}
                        ms.Metrics["GCSys"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.GCSys, Name: "GCSys"}
                        ms.Metrics["HeapAlloc"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.HeapAlloc, Name: "HeapAlloc"}
                        ms.Metrics["HeapIdle"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.HeapIdle, Name: "HeapIdle"}
                        ms.Metrics["HeapInuse"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.HeapInuse, Name: "HeapInuse"}
                        ms.Metrics["HeapObjects"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.HeapObjects, Name: "HeapObjects"}
                        ms.Metrics["HeapReleased"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.HeapReleased, Name: "HeapReleased"}
                        ms.Metrics["HeapSys"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.HeapSys, Name: "HeapSys"}
                        ms.Metrics["LastGC"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.LastGC, Name: "LastGC"}
                        ms.Metrics["Lookups"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.Lookups, Name: "Lookups"}
                        ms.Metrics["MCacheInuse"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.MCacheInuse, Name: "MCacheInuse"}
                        ms.Metrics["MCacheSys"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.MCacheSys, Name: "MCacheSys"}
                        ms.Metrics["MSpanInuse"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.MSpanInuse, Name: "MSpanInuse"}
                        ms.Metrics["MSpanSys"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.MSpanSys, Name: "MSpanSys"}
                        ms.Metrics["Mallocs"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.Mallocs, Name: "Mallocs"}
                        ms.Metrics["NextGC"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.NextGC, Name: "NextGC"}
                        ms.Metrics["NumForcedGC"] = &amp;models.Metric[uint32]{Type: configagent.MetricTypeGauge, Value: rtm.NumForcedGC, Name: "NumForcedGC"}
                        ms.Metrics["NumGC"] = &amp;models.Metric[uint32]{Type: configagent.MetricTypeGauge, Value: rtm.NumGC, Name: "NumGC"}
                        ms.Metrics["OtherSys"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.OtherSys, Name: "OtherSys"}
                        ms.Metrics["PauseTotalNs"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.PauseTotalNs, Name: "PauseTotalNs"}
                        ms.Metrics["StackInuse"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.StackInuse, Name: "StackInuse"}
                        ms.Metrics["StackSys"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.StackSys, Name: "StackSys"}
                        ms.Metrics["Sys"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.Sys, Name: "Sys"}
                        ms.Metrics["TotalAlloc"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rtm.TotalAlloc, Name: "TotalAlloc"}
                        ms.Metrics["PollCount"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeCounter, Value: ms.Metrics["PollCount"].GetValue().(uint64) + 1, Name: "PollCount"}
                        ms.Metrics["RandomValue"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: rand.Uint64(), Name: "RandomValue"}
                        ms.mutex.Unlock()
                        log.Info("metric pooling finished")</span>
                }
        }
}

// CollectAddition Collect starts collecting gopsutil metrics.
func (ms *MonitorService) CollectAddition(ctx context.Context) <span class="cov0" title="0">{
        log := ms.log.With(
                slog.String("info", "SERVICE LAYER: agentmetricservice.Start"),
        )

        virtMem, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err.Error())
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Info("stop signal received")
                        return</span>
                case &lt;-time.After(time.Duration(ms.cfg.PollInterval) * time.Second):<span class="cov0" title="0">
                        ms.mutex.Lock()
                        log.Info("starts CollectAddingMetrics metrics pooling")

                        utilCPU, err := ms.calculateUtilization()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err.Error())
                                continue</span>
                        }
                        <span class="cov0" title="0">ms.Metrics["CPUutilization1"] = &amp;models.Metric[float64]{Type: configagent.MetricTypeGauge, Value: utilCPU, Name: "CPUutilization1"}
                        ms.Metrics["TotalMemory"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: virtMem.Total, Name: "TotalMemory"}
                        ms.Metrics["FreeMemory"] = &amp;models.Metric[uint64]{Type: configagent.MetricTypeGauge, Value: virtMem.Available, Name: "FreeMemory"}
                        log.Info("metric pooling finished")
                        ms.mutex.Unlock()</span>
                }
        }
}

// GetMetrics return collected metrics as thread safe map.
func (ms *MonitorService) GetMetrics() map[string]models.MetricInteraction <span class="cov0" title="0">{
        ms.mutex.Lock()
        defer ms.mutex.Unlock()
        return ms.Metrics
}</span>

func (ms *MonitorService) calculateUtilization() (float64, error) <span class="cov0" title="0">{
        // get available cpu
        numCPUs := runtime.NumCPU()

        // Get cpu loading statistic
        cpuPercent, err := cpu.Percent(time.Second, false)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // calculate average CPU loading
        <span class="cov0" title="0">totalPercent := 0.0
        for _, percent := range cpuPercent </span><span class="cov0" title="0">{
                totalPercent += percent
        }</span>
        <span class="cov0" title="0">return totalPercent / float64(numCPUs), nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package metricsservice

import (
        "context"
        "errors"
        "log/slog"

        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "github.com/AlexBlackNn/metrics/internal/domain/models"
        "github.com/AlexBlackNn/metrics/pkg/storage"
)

type MetricsStorage interface {
        UpdateMetric(
                ctx context.Context,
                metric models.MetricGetter,
        ) error
        UpdateSeveralMetrics(
                ctx context.Context,
                metrics map[string]models.MetricGetter,
        ) error
        GetMetric(
                ctx context.Context,
                metric models.MetricGetter,
        ) (models.MetricGetter, error)
        GetAllMetrics(
                ctx context.Context,
        ) ([]models.MetricGetter, error)
}

type HealthChecker interface {
        HealthCheck(
                ctx context.Context,
        ) error
}

type MetricService struct {
        log            *slog.Logger
        cfg            *configserver.Config
        metricsStorage MetricsStorage
        healthChecker  HealthChecker
}

// New returns a new instance of MonitoringService.
func New(
        log *slog.Logger,
        cfg *configserver.Config,
        metricsStorage MetricsStorage,
        healthChecker HealthChecker,
) *MetricService <span class="cov8" title="1">{
        return &amp;MetricService{
                log:            log,
                cfg:            cfg,
                metricsStorage: metricsStorage,
                healthChecker:  healthChecker,
        }
}</span>

// UpdateMetricValue updates metric value or create new metric.
func (ms *MetricService) UpdateMetricValue(ctx context.Context, metric models.MetricInteraction) error <span class="cov8" title="1">{
        log := ms.log.With(
                slog.String("info", "SERVICE LAYER: metrics_service.UpdateMetricValue"),
        )
        log.Info("starts update metric value")

        if metric.GetType() == configserver.MetricTypeCounter </span><span class="cov8" title="1">{

                metricStorage, err := ms.metricsStorage.GetMetric(ctx, metric)
                if errors.Is(err, storage.ErrMetricNotFound) </span><span class="cov8" title="1">{
                        err = ms.metricsStorage.UpdateMetric(ctx, metric)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err.Error())
                                return ErrCouldNotUpdateMetric
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        log.Error(err.Error())
                        return ErrCouldNotUpdateMetric
                }</span>
                <span class="cov8" title="1">err = metric.AddValue(metricStorage)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err.Error())
                        return ErrCouldNotUpdateMetric
                }</span>
                <span class="cov8" title="1">err = ms.metricsStorage.UpdateMetric(ctx, metric)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err.Error())
                        return ErrCouldNotUpdateMetric
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">err := ms.metricsStorage.UpdateMetric(ctx, metric)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err.Error())
                return ErrCouldNotUpdateMetric
        }</span>
        <span class="cov8" title="1">log.Info("finish updating metric value")
        return nil</span>
}

// UpdateSeveralMetrics updates several metric value or create new ones.
func (ms *MetricService) UpdateSeveralMetrics(ctx context.Context, metrics []models.MetricInteraction) error <span class="cov8" title="1">{
        log := ms.log.With(
                slog.String("info", "SERVICE LAYER: metrics_service.UpdateSeveralMetrics"),
        )
        log.Info("starts update several metric values")

        tmpMetricsReduces := make(map[string]models.MetricGetter)

        // If several received metrics have the same name and type counter - calculate result value.
        // In case of type being gauge - just save the last value.
        // Such calculation decreases quantity of data to write in database.
        for _, oneMetric := range metrics </span><span class="cov8" title="1">{
                // if value already exists in tmpMetricsReduces
                if metric, ok := tmpMetricsReduces[oneMetric.GetName()]; ok &amp;&amp; metric.GetType() == "counter" </span><span class="cov0" title="0">{
                        err := oneMetric.AddValue(metric)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("failed to add value to metric", "metric", oneMetric.GetName(), "err", err.Error())
                                return err
                        }</span>

                        // if value is absent in tmpMetricsReduces and type counter (at the beginning of UpdateSeveralMetrics)
                } else<span class="cov8" title="1"> if oneMetric.GetType() == "counter" </span><span class="cov8" title="1">{
                        // try to load data from database
                        metricStorage, err := ms.metricsStorage.GetMetric(ctx, oneMetric)
                        if err != nil </span><span class="cov0" title="0">{
                                if !errors.Is(err, storage.ErrMetricNotFound) </span><span class="cov0" title="0">{
                                        log.Error(err.Error())
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">if errors.Is(err, storage.ErrMetricNotFound) </span><span class="cov0" title="0">{
                                tmpMetricsReduces[oneMetric.GetName()] = oneMetric
                                log.Error(err.Error())
                                continue</span>
                        }
                        // if data exists then add to received metric
                        <span class="cov8" title="1">err = oneMetric.AddValue(metricStorage)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("failed to add value to metric", "metric", oneMetric.GetName(), "err", err)
                                return err
                        }</span>
                }
                <span class="cov8" title="1">tmpMetricsReduces[oneMetric.GetName()] = oneMetric</span>
        }

        <span class="cov8" title="1">err := ms.metricsStorage.UpdateSeveralMetrics(ctx, tmpMetricsReduces)
        if err != nil </span><span class="cov0" title="0">{
                log.Info("failed to update several metric values", "err", err.Error())
                return err
        }</span>
        <span class="cov8" title="1">log.Info("finish updating metric value")
        return nil</span>
}

// GetOneMetricValue extracts metric.
func (ms *MetricService) GetOneMetricValue(ctx context.Context, metric models.MetricGetter) (models.MetricGetter, error) <span class="cov8" title="1">{
        log := ms.log.With(
                slog.String("info", "SERVICE LAYER: metrics_service.GetOneMetricValue"),
        )
        log.Info("starts getting metric value")
        metric, err := ms.metricsStorage.GetMetric(ctx, metric)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, storage.ErrMetricNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrMetricNotFound
                }</span>
                <span class="cov0" title="0">log.Error(err.Error())
                return nil, ErrCouldNotGetMetric</span>
        }
        <span class="cov8" title="1">log.Info("finish getting metric value")
        return metric, nil</span>
}

// GetAllMetrics extracts all metric.
func (ms *MetricService) GetAllMetrics(ctx context.Context) ([]models.MetricGetter, error) <span class="cov0" title="0">{
        log := ms.log.With(
                slog.String("info", "SERVICE LAYER: metrics_service.GetAllMetrics"),
        )
        log.Info("starts getting all metrics")

        metrics, err := ms.metricsStorage.GetAllMetrics(ctx)

        if err != nil </span><span class="cov0" title="0">{
                log.Error(err.Error())
                if errors.Is(err, storage.ErrMetricNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrMetricNotFound
                }</span>
                <span class="cov0" title="0">return nil, ErrCouldNotUpdateMetric</span>
        }
        <span class="cov0" title="0">log.Info("finish getting all metrics")
        return metrics, nil</span>
}

// HealthCheck returns service health check
func (ms *MetricService) HealthCheck(ctx context.Context) error <span class="cov8" title="1">{
        log := ms.log.With(
                slog.String("info", "SERVICE LAYER: metrics_service.HealthCheck"),
        )
        log.Info("starts getting health check")
        defer log.Info("finish getting health check")
        return ms.healthChecker.HealthCheck(ctx)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package memstorage

import (
        "encoding/json"
        "github.com/AlexBlackNn/metrics/internal/domain/models"
)

type dataBase map[string]models.MetricGetter

func (db *dataBase) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{

        // Can't unmarshal to models.MetricInteraction (interface).
        var TempDBMetric map[string]TempMetric

        if err := json.Unmarshal(data, &amp;TempDBMetric); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, v := range TempDBMetric </span><span class="cov0" title="0">{
                v := v
                metric, err := models.New(v.Type, v.Name, v.GetStringValue())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">(*db)[v.Name] = metric</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package memstorage

import (
        "bufio"
        "bytes"
        "encoding/gob"
        "errors"
        "fmt"
        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "github.com/AlexBlackNn/metrics/internal/domain/models"
        "log/slog"
        "os"
        "sync"
)

func init() <span class="cov8" title="1">{
        gob.Register(models.Metric[uint64]{})
        gob.Register(models.Metric[float64]{})
        gob.Register(encodeMetricUint64)
        gob.Register(encodeMetricFloat64)

}</span>

// dataBaseJSONStateManager saves and restores database state.
type dataBaseGOBStateManager struct {
        cfg   *configserver.Config
        log   *slog.Logger
        db    dataBase
        mutex *sync.RWMutex
}

// Custom gob encoder for models.Metric[uint64].
func encodeMetricUint64(enc *gob.Encoder, m models.Metric[uint64]) error <span class="cov0" title="0">{
        return enc.Encode(struct {
                Name  string
                Type  string
                Value uint64
        }{
                Name:  m.Name,
                Type:  m.Type,
                Value: m.Value,
        })
}</span>

// Custom gob encoder for models.Metric[uint64].
func encodeMetricFloat64(enc *gob.Encoder, m models.Metric[float64]) error <span class="cov0" title="0">{
        return enc.Encode(struct {
                Name  string
                Type  string
                Value float64
        }{
                Name:  m.Name,
                Type:  m.Type,
                Value: m.Value,
        })
}</span>

func (gm *dataBaseGOBStateManager) saveMetrics() error <span class="cov0" title="0">{
        log := gm.log.With(
                slog.String("info", "STORAGE LAYER: gob_state_manager.saveMetrics"),
        )
        log.Debug("starts saving metric")

        gm.mutex.RLock()
        defer gm.mutex.RUnlock()
        file, err := os.OpenFile(
                gm.cfg.ServerFileStoragePath, os.O_WRONLY|os.O_CREATE, 0777,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(file *os.File) </span><span class="cov0" title="0">{
                err = file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to close file", "err", err)
                }</span>
        }(file)
        <span class="cov0" title="0">writer := bufio.NewWriter(file)
        defer writer.Flush()
        var buffer bytes.Buffer
        if err = gob.NewEncoder(&amp;buffer).Encode(gm.db); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return err
        }</span>
        <span class="cov0" title="0">_, err = writer.Write(buffer.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (gm *dataBaseGOBStateManager) restoreMetrics() error <span class="cov8" title="1">{
        log := gm.log.With(
                slog.String("info", "STORAGE LAYER: gob_state_manager.restoreMetrics"),
        )
        log.Info("restore saved metric")
        gm.mutex.RLock()
        defer gm.mutex.RUnlock()
        file, err := os.OpenFile(
                gm.cfg.ServerFileStoragePath, os.O_RDONLY, 0777,
        )
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(file *os.File) </span><span class="cov0" title="0">{
                err = file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to close file", "err", err)
                }</span>
        }(file)

        <span class="cov0" title="0">reader := bufio.NewReader(file)
        dec := gob.NewDecoder(reader)

        // Decode the data into a map[string]interface{}.
        var decodedData map[string]interface{}
        if err = dec.Decode(&amp;decodedData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for k, v := range decodedData </span><span class="cov0" title="0">{
                switch v := v.(type) </span>{
                case models.Metric[uint64]:<span class="cov0" title="0">
                        gm.db[k] = &amp;v</span>
                case models.Metric[float64]:<span class="cov0" title="0">
                        gm.db[k] = &amp;v</span>
                default:<span class="cov0" title="0">
                        return errors.New("unknown type")</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package memstorage

import (
        "bufio"
        "encoding/json"
        "fmt"
        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "io"
        "log/slog"
        "os"
        "sync"
)

// dataBaseJSONStateManager saves and restores database state.
type dataBaseJSONStateManager struct {
        cfg   *configserver.Config
        log   *slog.Logger
        db    dataBase
        mutex *sync.RWMutex
}

func (jm *dataBaseJSONStateManager) saveMetrics() error <span class="cov0" title="0">{
        log := jm.log.With(
                slog.String("info", "STORAGE LAYER: json_state_manager.saveMetrics"),
        )
        log.Debug("starts saving metric")
        jm.mutex.RLock()
        defer jm.mutex.RUnlock()
        file, err := os.OpenFile(
                jm.cfg.ServerFileStoragePath, os.O_WRONLY|os.O_CREATE, 0777,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "STORAGE LAYER: json_state_manager.saveMetrics: couldn't open metric file: %w",
                        err,
                )
        }</span>
        <span class="cov0" title="0">defer func(file *os.File) </span><span class="cov0" title="0">{
                err = file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to close file", "err", err)
                }</span>
        }(file)
        <span class="cov0" title="0">writer := bufio.NewWriter(file)
        defer writer.Flush()

        dataBaseBytes, err := json.Marshal(jm.db)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = writer.Write(dataBaseBytes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (jm *dataBaseJSONStateManager) restoreMetrics() error <span class="cov0" title="0">{
        log := jm.log.With(
                slog.String("info", "STORAGE LAYER: json_state_manager.restoreMetrics"),
        )
        log.Info("restore saved metric")

        jm.mutex.RLock()
        defer jm.mutex.RUnlock()
        file, err := os.OpenFile(
                jm.cfg.ServerFileStoragePath, os.O_RDONLY, 0777,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(file *os.File) </span><span class="cov0" title="0">{
                err = file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to close file", "err", err)
                }</span>
        }(file)

        <span class="cov0" title="0">reader := bufio.NewReader(file)
        tmpBuffer, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "STORAGE LAYER: json_state_manager.restoreMetrics: couldn't read metric file: %w",
                        err,
                )
        }</span>

        <span class="cov0" title="0">return json.Unmarshal(tmpBuffer, &amp;jm.db)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package memstorage

import (
        "context"
        "fmt"
        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "github.com/AlexBlackNn/metrics/internal/domain/models"
        "github.com/AlexBlackNn/metrics/pkg/storage"
        "log/slog"
        "sync"
        "time"
)

type StateManager interface {
        saveMetrics() error
        restoreMetrics() error
}

type MemStorage struct {
        mutex    *sync.RWMutex
        db       dataBase
        cfg      *configserver.Config
        sm       StateManager
        log      *slog.Logger
        saveChan chan struct{}
}

// New inits mem storage (map structure)
func New(cfg *configserver.Config, log *slog.Logger) (*MemStorage, error) <span class="cov8" title="1">{
        db := make(dataBase)
        mutex := &amp;sync.RWMutex{}
        memStorage := MemStorage{
                mutex:    mutex,
                cfg:      cfg,
                db:       db,
                log:      log,
                sm:       &amp;dataBaseGOBStateManager{cfg: cfg, db: db, mutex: mutex, log: log},
                saveChan: make(chan struct{}),
        }

        go func() </span><span class="cov8" title="1">{
                memStorage.saveMetricToDisk()
        }</span>()

        <span class="cov8" title="1">if cfg.ServerRestore </span><span class="cov8" title="1">{
                _ = memStorage.sm.restoreMetrics()
        }</span>
        <span class="cov8" title="1">return &amp;memStorage, nil</span>
}

// saveMetricToDisk saves metrics to disk.
func (ms *MemStorage) saveMetricToDisk() <span class="cov8" title="1">{
        log := ms.log.With(
                slog.String("info", "STORAGE LAYER: mem_storage.saveMetricToDisk"),
        )
        storeInterval := time.Duration(ms.cfg.ServerStoreInterval) * time.Second
        for </span><span class="cov8" title="1">{
                if ms.cfg.ServerStoreInterval &gt; 0 </span><span class="cov8" title="1">{
                        &lt;-time.After(storeInterval)
                        log.Debug("starts saving metric to disk")
                        err := ms.sm.saveMetrics()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("failed save metrics", "err", err)
                        }</span> else<span class="cov0" title="0"> {
                                log.Debug("finish save metric to disk")
                        }</span>
                } else<span class="cov0" title="0"> {
                        &lt;-ms.saveChan
                        log.Debug("starts saving metric to disk")
                        err := ms.sm.saveMetrics()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("failed save metrics", "err", err)
                        }</span> else<span class="cov0" title="0"> {
                                log.Debug("finish save metric to disk")
                        }</span>
                }
        }
}

func (ms *MemStorage) HealthCheck(
        ctx context.Context,
) error <span class="cov8" title="1">{
        return nil
}</span>

// UpdateMetric updates metric value in mem storage.
func (ms *MemStorage) UpdateMetric(
        ctx context.Context,
        metric models.MetricGetter,
) error <span class="cov8" title="1">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("aborting work: %v, because of %w", ctx.Err(), context.Cause(ctx))</span>
        default:<span class="cov8" title="1">
                ms.mutex.Lock()
                ms.db[metric.GetName()] = metric
                ms.mutex.Unlock()
                if ms.cfg.ServerStoreInterval == 0 </span><span class="cov0" title="0">{
                        ms.saveChan &lt;- struct{}{}
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// GetMetric gets metric value from mem storage.
func (ms *MemStorage) GetMetric(
        ctx context.Context,
        metric models.MetricGetter,
) (models.MetricGetter, error) <span class="cov8" title="1">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, fmt.Errorf("aborting work: %v, because of %w", ctx.Err(), context.Cause(ctx))</span>
        default:<span class="cov8" title="1">
                ms.mutex.RLock()
                defer ms.mutex.RUnlock()
                metric, ok := ms.db[metric.GetName()]
                if !ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf(
                                "DATA LAYER: storage.mem_storage.GetMetric: %w",
                                storage.ErrMetricNotFound,
                        )
                }</span>
                <span class="cov8" title="1">return metric, nil</span>
        }
}

func (ms *MemStorage) UpdateSeveralMetrics(
        ctx context.Context,
        metrics map[string]models.MetricGetter,
) error <span class="cov8" title="1">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("aborting work: %v, because of %w", ctx.Err(), context.Cause(ctx))</span>
        default:<span class="cov8" title="1">
                ms.mutex.RLock()
                defer ms.mutex.RUnlock()
                for _, oneMetric := range metrics </span><span class="cov8" title="1">{
                        ms.db[oneMetric.GetName()] = oneMetric
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// GetAllMetrics gets metric value from mem storage.
func (ms *MemStorage) GetAllMetrics(
        ctx context.Context,
) ([]models.MetricGetter, error) <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, fmt.Errorf("aborting work: %v, because of %w", ctx.Err(), context.Cause(ctx))</span>
        default:<span class="cov0" title="0">
                var metrics []models.MetricGetter
                if len(ms.db) == 0 </span><span class="cov0" title="0">{
                        return []models.MetricGetter{}, fmt.Errorf(
                                "DATA LAYER: storage.mem_storage.GetAllMetrics: %w",
                                storage.ErrMetricNotFound,
                        )
                }</span>
                <span class="cov0" title="0">ms.mutex.RLock()
                defer ms.mutex.RUnlock()
                for _, oneMetric := range ms.db </span><span class="cov0" title="0">{
                        metrics = append(metrics, oneMetric)
                }</span>
                <span class="cov0" title="0">return metrics, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package memstorage

import (
        "fmt"

        "github.com/AlexBlackNn/metrics/internal/config/configserver"
)

// TempMetric is a template to deserialize data from bytes
// (models.MetricGetter and generic types can't be used here).
type TempMetric struct {
        Type  string
        Name  string
        Value any
}

func (m *TempMetric) GetType() string <span class="cov8" title="1">{
        return m.Type
}</span>

func (m *TempMetric) GetName() string <span class="cov8" title="1">{
        return m.Name
}</span>

func (m *TempMetric) GetValue() any <span class="cov8" title="1">{
        return m.Value
}</span>

func (m *TempMetric) GetStringValue() string <span class="cov8" title="1">{
        if m.GetType() == configserver.MetricTypeCounter </span><span class="cov8" title="1">{
                if value, ok := m.GetValue().(float64); ok </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%d", int(value))
                }</span>
                <span class="cov8" title="1">if value, ok := m.GetValue().(int64); ok </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%d", value)
                }</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("%g", m.GetValue())</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package postgres is a data layer which communicate with postgresql database.
package postgres

import (
        "bytes"
        "context"
        "database/sql"
        "errors"
        "fmt"
        "log/slog"

        "github.com/AlexBlackNn/metrics/internal/config/configserver"
        "github.com/AlexBlackNn/metrics/internal/domain/models"
        "github.com/AlexBlackNn/metrics/pkg/storage"
        _ "github.com/jackc/pgx/v5/stdlib"
)

// PostStorage client to communicate with postgresql
type PostStorage struct {
        tmpl Tmpl
        db   *sql.DB
}

// GetType is a helper function to get the type.
func GetType(m models.MetricGetter) string <span class="cov8" title="1">{
        return m.GetType()
}</span>

// New creates client for concurrent use by multiple goroutines and maintains its own pool of idle connections.
func New(cfg *configserver.Config, log *slog.Logger) (*PostStorage, error) <span class="cov8" title="1">{
        db, err := sql.Open("pgx", cfg.ServerDataBaseDSN)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Unable to connect to database", "error", err)
                return nil, fmt.Errorf(
                        "DATA LAYER: storage.postgres.GetMetric: %w - %v",
                        storage.ErrConnectionFailed, err,
                )
        }</span>
        <span class="cov8" title="1">return &amp;PostStorage{db: db, tmpl: NewTemplate()}, nil</span>
}

// Stop closes connection to DB.
func (s *PostStorage) Stop() error <span class="cov0" title="0">{
        return s.db.Close()
}</span>

// UpdateMetric updates metric value.
func (s *PostStorage) UpdateMetric(
        ctx context.Context,
        metric models.MetricGetter,
) error <span class="cov8" title="1">{
        var sqlTmp bytes.Buffer
        err := s.tmpl["UpdateMetric"].Execute(&amp;sqlTmp, metric)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "DATA LAYER: storage.postgres.UpdateMetric: couldn't create template: %w - %v",
                        storage.ErrSQLExec, err,
                )
        }</span>

        <span class="cov8" title="1">_, err = s.db.ExecContext(
                ctx, sqlTmp.String(), metric.GetType(), metric.GetName(), metric.GetValue(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "DATA LAYER: storage.postgres.UpdateMetric: couldn't save metric: %w - %v",
                        storage.ErrSQLExec, err,
                )
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdateSeveralMetrics updates several metric value.
func (s *PostStorage) UpdateSeveralMetrics(
        ctx context.Context,
        metrics map[string]models.MetricGetter,
) error <span class="cov8" title="1">{
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "DATA LAYER: storage.postgres.UpdateSeveralMetrics: couldn't open transaction: %w - %v",
                        storage.ErrSQLExec, err,
                )
        }</span>
        <span class="cov8" title="1">defer func(tx *sql.Tx) </span><span class="cov8" title="1">{
                tx.Rollback()
        }</span>(tx)

        <span class="cov8" title="1">sqlTmpStms := make(map[string]string)
        sqlTmpStms[configserver.MetricTypeGauge] = "INSERT INTO app.gauge_part (metric_id, name, value) VALUES ((SELECT uuid FROM app.types WHERE name = $1), $2, $3)"
        sqlTmpStms[configserver.MetricTypeCounter] = "INSERT INTO app.counter_part (metric_id, name, value) VALUES ((SELECT uuid FROM app.types WHERE name = $1), $2, $3)"

        // This prepared statements seem to be unnecessary, because Exec creates Prepare statement under the hood.
        preparedStmt := make(map[string]*sql.Stmt)
        for name, onesqlTmpStms := range sqlTmpStms </span><span class="cov8" title="1">{
                stmt, err := tx.PrepareContext(ctx, onesqlTmpStms)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "DATA LAYER: storage.postgres.UpdateSeveralMetrics: couldn't prepare context: %w - %v",
                                storage.ErrSQLExec, err,
                        )
                }</span>
                <span class="cov8" title="1">preparedStmt[name] = stmt</span>
        }
        // The statements prepared for a transaction by calling the transaction's Tx.Prepare or Tx.Stmt methods
        //are closed by the call to Tx.Commit or Tx.Rollback. https://pkg.go.dev/database/sql#Tx
        // BUT it must be proved in pgx docs or code
        //TODO: prove or refute
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                for _, onesqlTmpStms := range preparedStmt </span><span class="cov8" title="1">{
                        onesqlTmpStms.Close()
                }</span>
        }()

        <span class="cov8" title="1">for _, oneMetric := range metrics </span><span class="cov8" title="1">{
                _, err = preparedStmt[oneMetric.GetType()].ExecContext(
                        ctx, oneMetric.GetType(), oneMetric.GetName(), oneMetric.GetValue(),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "DATA LAYER: storage.postgres.UpdateSeveralMetrics: couldn't save metric: %w - %v",
                                storage.ErrSQLExec, err,
                        )
                }</span>
        }
        <span class="cov8" title="1">return tx.Commit()</span>
}

// GetMetric updates gets metric value.
func (s *PostStorage) GetMetric(
        ctx context.Context,
        metric models.MetricGetter,
) (models.MetricGetter, error) <span class="cov8" title="1">{

        var sqlTmp bytes.Buffer
        err := s.tmpl["GetMetric"].Execute(&amp;sqlTmp, metric)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">row := s.db.QueryRowContext(
                ctx,
                sqlTmp.String(),
                metric.GetName(),
        )

        var tmpMetric TempMetric
        err = row.Scan(&amp;tmpMetric.Type, &amp;tmpMetric.Name, &amp;tmpMetric.Value)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(
                                "DATA LAYER: storage.postgres.GetMetric: %w - %v",
                                storage.ErrMetricNotFound, err,
                        )
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf(
                        "DATA LAYER: storage.postgres.GetMetric: %w - %v",
                        storage.ErrSQLExec, err,
                )</span>
        }
        <span class="cov8" title="1">metricDB, err := models.New(
                tmpMetric.GetType(),
                tmpMetric.GetName(),
                tmpMetric.GetStringValue(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "DATA LAYER: storage.postgres.GetMetric: models.New %w - %v",
                        storage.ErrUnexpectedBehavior, err,
                )
        }</span>
        <span class="cov8" title="1">return metricDB, nil</span>
}

// GetAllMetrics gets all metric values.
func (s *PostStorage) GetAllMetrics(
        ctx context.Context,
) ([]models.MetricGetter, error) <span class="cov8" title="1">{
        var metrics []models.MetricGetter
        var sqlTmp bytes.Buffer
        err := s.tmpl["GetAllMetric"].Execute(&amp;sqlTmp, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">rows, err := s.db.QueryContext(
                ctx,
                sqlTmp.String(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "DATA LAYER: storage.postgres.GetAllMetrics: %w - %v",
                        storage.ErrSQLExec, err,
                )
        }</span>
        <span class="cov8" title="1">defer func(rows *sql.Rows) </span><span class="cov8" title="1">{
                err = errors.Join(err, rows.Close())
        }</span>(rows)

        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                var tmpMetric TempMetric
                err = rows.Scan(&amp;tmpMetric.Type, &amp;tmpMetric.Name, &amp;tmpMetric.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(
                                "DATA LAYER: storage.postgres.GetAllMetrics: rows.Scan %w - %v",
                                storage.ErrUnexpectedBehavior, err,
                        )
                }</span>

                <span class="cov8" title="1">metricDB, err := models.New(
                        tmpMetric.GetType(),
                        tmpMetric.GetName(),
                        tmpMetric.GetStringValue(),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(
                                "DATA LAYER: storage.postgres.GetAllMetrics: models.New %w - %v",
                                storage.ErrUnexpectedBehavior, err,
                        )
                }</span>
                <span class="cov8" title="1">metrics = append(metrics, metricDB)</span>
        }
        <span class="cov8" title="1">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "DATA LAYER: storage.postgres.GetAllMetrics: rows.Err %w - %v",
                        storage.ErrUnexpectedBehavior, err,
                )
        }</span>
        <span class="cov8" title="1">return metrics, nil</span>
}

// HealthCheck provides service health check.
func (s *PostStorage) HealthCheck(
        ctx context.Context,
) error <span class="cov8" title="1">{
        err := s.db.PingContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "DATA LAYER: storage.postgres.HealthCheck: %w - %v",
                        storage.ErrConnectionFailed, err,
                )
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package postgres

import "text/template"

type Tmpl map[string]*template.Template

func NewTemplate() Tmpl <span class="cov8" title="1">{
        tmpl := Tmpl{}
        tmpl["GetMetric"] = template.Must(template.New("sqlQuery").Funcs(template.FuncMap{
                "GetType": GetType,
        }).Parse(`
      WITH LatestCounter AS (
        SELECT
          MAX(created) AS latest_created
        FROM
          app.{{GetType .}}_part
        WHERE
          app.{{GetType .}}_part.name = $1
      )
      SELECT
        t.name, c.name, c.value
      FROM
        app.{{GetType .}}_part as c
      JOIN
        app.types as t ON c.metric_id = t.uuid
      JOIN
        LatestCounter lc ON c.created = lc.latest_created
      WHERE
        c.name = $1
      ORDER BY c.created;
  `))

        tmpl["UpdateMetric"] = template.Must(template.New("sqlQuery").Funcs(template.FuncMap{
                "GetType": GetType,
        }).Parse(`
      INSERT INTO
    app.{{GetType .}}_part (metric_id, name, value)
        VALUES ((SELECT uuid FROM app.types WHERE name = $1), $2, $3)
        `))

        tmpl["GetAllMetric"] = template.Must(template.New("sqlQuery").Parse(`
        WITH LatestCounter AS (
                SELECT
                        MAX(created) AS latest_created, name
                FROM
                        app.counter_part
                GROUP BY
                        name
        ), LatestGauge AS (
                SELECT
                        MAX(created) AS latest_created, name
                FROM
                        app.gauge_part
                GROUP BY
                        name
        )
        SELECT
                t.name, c.name, c.value
        FROM
                app.counter_part as c
                        JOIN
                app.types as t ON c.metric_id = t.uuid
                        JOIN
                LatestCounter lc ON c.created = lc.latest_created AND c.name = lc.name
        UNION
        SELECT
                t.name, g.name, g.value
        FROM
                app.gauge_part as g
                        JOIN
                app.types as t ON g.metric_id = t.uuid
                        JOIN
                LatestGauge lc ON g.created = lc.latest_created AND g.name = lc.name
`))
        return tmpl
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package postgres

import (
        "fmt"

        "github.com/AlexBlackNn/metrics/internal/config/configserver"
)

// TempMetric is a template to deserialize data from bytes
// (models.MetricGetter and generic types can't be used here).
type TempMetric struct {
        Type  string
        Name  string
        Value any
}

func (m *TempMetric) GetType() string <span class="cov8" title="1">{
        return m.Type
}</span>

func (m *TempMetric) GetName() string <span class="cov8" title="1">{
        return m.Name
}</span>

func (m *TempMetric) GetValue() any <span class="cov8" title="1">{
        return m.Value
}</span>

func (m *TempMetric) GetStringValue() string <span class="cov8" title="1">{
        if m.GetType() == configserver.MetricTypeCounter </span><span class="cov8" title="1">{
                if value, ok := m.GetValue().(float64); ok </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%d", int(value))
                }</span>
                <span class="cov8" title="1">if value, ok := m.GetValue().(int64); ok </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%d", value)
                }</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("%g", m.GetValue())</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
